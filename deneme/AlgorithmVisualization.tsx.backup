import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Animated,
  ScrollView,
  Dimensions,
  TextInput,
  Alert,
  Button,
  Modal,
} from 'react-native';
import { AlgorithmInfoCard } from './VisualizationHelpers';

// Sabitler
const DEFAULT_ANIMATION_SPEED = 500; // Milisaniye cinsinden varsayÄ±lan animasyon hÄ±zÄ±
const DEFAULT_ARRAY_SIZE = 8; // VarsayÄ±lan dizi boyutu
const BAR_WIDTH = 30; // Bar geniÅŸliÄŸi
const BAR_MARGIN = 5; // Bar kenar boÅŸluÄŸu
const MAX_BAR_HEIGHT = 200; // Maksimum bar yÃ¼ksekliÄŸi

// Array GÃ¶rselleÅŸtirme Props ArayÃ¼zÃ¼
interface ArrayVisualizationProps {
  algorithmType: string;
  title: string;
  animationSpeed?: number; // Milisaniye cinsinden animasyon hÄ±zÄ±
  customArray?: number[]; // Ä°steÄŸe baÄŸlÄ± Ã¶zel dizi
}

// Rastgele dizi oluÅŸtur
const generateRandomArray = (length: number, maxValue: number): number[] => {
  return Array.from({ length }, () => Math.floor(Math.random() * maxValue) + 10);
};

// Algoritma GÃ¶rselleÅŸtirme bileÅŸeni
const AlgorithmVisualization: React.FC<ArrayVisualizationProps> = ({
  algorithmType,
  title,
  animationSpeed = DEFAULT_ANIMATION_SPEED,
  customArray,
}) => {
  // Render fonksiyonu iÃ§in dÃ¼zeltme
  const renderContent = () => {
    // JSX iÃ§eriÄŸi buraya gelecek
    return (
      <View style={{ flex: 1, padding: 10 }}>
        <Text>Algoritma gÃ¶rselleÅŸtirici</Text>
      </View>
    );
  };
  
  return renderContent();
  // Ä°nput deÄŸeri iÃ§in state (eÄŸer tanÄ±mlanmamÄ±ÅŸsa)
  const [deleteValue, setDeleteValue] = useState<string>('');
  
  // BaÄŸlantÄ± Ã§izim fonksiyonu
  const drawArrow = (fromIndex: number, toIndex: number) => {
    // Bu fonksiyon dairesel baÄŸlantÄ±yÄ± gÃ¶stermek iÃ§in kullanÄ±lÄ±r
    console.log(`Ã‡izilen ok: ${fromIndex} -> ${toIndex}`);
  };
  // Ekran geniÅŸliÄŸi Ã¶lÃ§Ã¼mÃ¼
  const windowWidth = Dimensions.get('window').width;
  
  // BaÄŸlÄ± liste tiplerini kontrol et
  const isLinkedList = algorithmType.toLowerCase().includes('linked') || 
                      algorithmType.toLowerCase().includes('baÄŸlÄ± liste') || 
                      algorithmType.toLowerCase().includes('dairesel');
  
  // DurumlarÄ± tanÄ±mla
  const [array, setArray] = useState<number[]>(() => {
    // EÄŸer baÄŸlÄ± liste ise varsayÄ±lan deÄŸerlerle baÅŸla
    if (isLinkedList) {
      if (customArray && customArray.length > 0) {
        return customArray;
      }
      return [42, 18, 27, 35, 53]; // BaÄŸlÄ± listeler iÃ§in Ã¶zel baÅŸlangÄ±Ã§ deÄŸerleri
    }
    return customArray || generateRandomArray(8, 100);
  });
  
  const [sorting, setSorting] = useState<boolean>(false);
  const [currentStep, setCurrentStep] = useState<number>(0);
  const [totalSteps, setTotalSteps] = useState<number>(0);
  const [speed, setSpeed] = useState<number>(animationSpeed);
  const [explanationText, setExplanationText] = useState<string>('GÃ¶rselleÅŸtirmeyi baÅŸlatmak iÃ§in "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
  const [searchTarget, setSearchTarget] = useState<string>('');
  
  // BaÄŸlÄ± liste iÃ§in ek state'ler
  const [selectedOperation, setSelectedOperation] = useState<string>('demo'); // SeÃ§ilen iÅŸlem
  const [inputValue, setInputValue] = useState<string>(''); // Ä°ÅŸlem iÃ§in girdi deÄŸeri
  const [insertValue, setInsertValue] = useState<string>(''); // Eklenecek deÄŸer
  const [insertPosition, setInsertPosition] = useState<string>(''); // Ekleme pozisyonu
  const [logMessages, setLogMessages] = useState<string[]>([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼
  
  // Animasyon deÄŸerlerini tut
  const barRefs = useRef<Animated.Value[]>([]);
  const barColors = useRef<Animated.Value[]>([]);
  
  // Animasyon renklerini ayarlamak iÃ§in yardÄ±mcÄ± fonksiyonlar
  const normalColor = 'rgb(108, 92, 231)'; // Mor
  const comparingColor = 'rgb(255, 165, 0)'; // Turuncu
  const swappingColor = 'rgb(255, 0, 0)'; // KÄ±rmÄ±zÄ±
  const sortedColor = 'rgb(46, 213, 115)'; // YeÅŸil
  
  // BaÄŸlÄ± listeler iÃ§in ek renkler
  const prevColor = 'rgb(52, 152, 219)'; // Mavi - previous
  const nextColor = 'rgb(230, 126, 34)'; // Turuncu - next
  const circularColor = 'rgb(155, 89, 182)'; // Mor - dairesel baÄŸlantÄ±
  const visitedColor = 'rgb(149, 165, 166)'; // Gri - ziyaret edilmiÅŸ
  
  // Her dizinin deÄŸiÅŸiminde animasyon deÄŸerlerini yenile
  useEffect(() => {
    // Ã–nceki referanslarÄ± temizle
    barRefs.current = [];
    barColors.current = [];
    
    try {
      // Her eleman iÃ§in yeni animasyon deÄŸerleri oluÅŸtur
      array.forEach(() => {
        barRefs.current.push(new Animated.Value(0));
        barColors.current.push(new Animated.Value(0));
      });
      
      // BaÅŸlangÄ±Ã§ta tÃ¼m barlarÄ± normal renge ayarla
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0); // 0 = normal renk
      });
      
      // Algoritma tipine gÃ¶re baÅŸlangÄ±Ã§ aÃ§Ä±klamasÄ±
      if (algorithmType.toLowerCase().includes('singly')) {
        setExplanationText('Tek YÃ¶nlÃ¼ BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
      } else if (algorithmType.toLowerCase().includes('doubly')) {
        setExplanationText('Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
      } else if (algorithmType.toLowerCase().includes('circular')) {
        setExplanationText('Dairesel BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
      } else {
        setExplanationText('GÃ¶rselleÅŸtirmeyi baÅŸlatmak iÃ§in "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
      }
    } catch (error) {
      console.error('Animasyon deÄŸerlerini baÅŸlatÄ±rken hata:', error);
    }
  }, [array, algorithmType]);
  
  // Yeni bir rastgele dizi oluÅŸtur
  const resetArray = () => {
    if (sorting) return; // SÄ±ralama iÅŸlemi sÄ±rasÄ±nda yeni dizi oluÅŸturma
    setArray(generateRandomArray(8, 100));
    setCurrentStep(0);
    setTotalSteps(0);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    // Algoritma tipine gÃ¶re baÅŸlangÄ±Ã§ aÃ§Ä±klamasÄ±
    if (algorithmType.toLowerCase().includes('singly')) {
      setExplanationText('Tek YÃ¶nlÃ¼ BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
    } else if (algorithmType.toLowerCase().includes('doubly')) {
      setExplanationText('Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
    } else if (algorithmType.toLowerCase().includes('circular')) {
      setExplanationText('Dairesel BaÄŸlÄ± Liste: Ä°ÅŸlem seÃ§in ve "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
    } else {
    setExplanationText('GÃ¶rselleÅŸtirmeyi baÅŸlatmak iÃ§in "BaÅŸlat" dÃ¼ÄŸmesine tÄ±klayÄ±n.');
    }
  };
  
  // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼ne mesaj ekle
  const addLogMessage = (message: string) => {
    setLogMessages(prevMessages => [...prevMessages, message]);
  };
  
  // Bekleme yardÄ±mcÄ± fonksiyonu
  const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
  
  // Tek YÃ¶nlÃ¼ BaÄŸlÄ± Liste gÃ¶rselleÅŸtirmesi
  const visualizeSinglyLinkedList = async () => {
    if (sorting) return;
    
    // Operasyon tipine gÃ¶re uygun fonksiyonu Ã§aÄŸÄ±r
    switch (selectedOperation) {
      case 'demo':
        await performLinkedListDemo();
        break;
      case 'prepend':
        await performPrepend();
        break;
      case 'append':
        await performAppend();
        break;
      case 'insert':
        await performInsertAt();
        break;
      case 'search':
        await performSearch();
        break;
      case 'deleteHead':
        await performDeleteHead();
        break;
      case 'deleteTail':
        await performDeleteTail();
        break;
      case 'deleteValue':
        await performDeleteValue();
        break;
      case 'traverse':
        await performTraverse();
        break;
      case 'clear':
        await performClear();
        break;
      default:
        setExplanationText('LÃ¼tfen bir iÅŸlem seÃ§in.');
    }
  };
  
  // Demo - TÃ¼m operasyonlarÄ± sÄ±rayla gÃ¶ster
  const performLinkedListDemo = async () => {
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(10);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      let linkedList = [...array];
      setExplanationText('ğŸ”— Tek YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo: Veri yapÄ±sÄ±nÄ±n temel operasyonlarÄ±nÄ± keÅŸfedelim...');
      addLogMessage('Tek YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo baÅŸlatÄ±ldÄ±');
      await wait(speed);
      
      // BaÄŸlÄ± liste spesifik demo adÄ±mlarÄ± - bu adÄ±mlara null kontrolÃ¼ ekleyeceÄŸiz
      const linkedListOperations = [
        { name: 'YapÄ± AÃ§Ä±klamasÄ±', action: async () => { try { await explainStructure(linkedList); } catch (e) { console.error(e); } } },
        { name: 'HEAD Pointer', action: async () => { try { await showHeadPointer(linkedList); } catch (e) { console.error(e); } } },
        { name: 'BaÅŸa Ekleme O(1)', action: async () => { try { await demoInsert(linkedList, 'head'); } catch (e) { console.error(e); } } },
        { name: 'Sona Ekleme O(n)', action: async () => { try { await demoInsert(linkedList, 'tail'); } catch (e) { console.error(e); } } },
        { name: 'DoÄŸrusal Arama O(n)', action: async () => { try { await demoSearch(linkedList); } catch (e) { console.error(e); } } },
        { name: 'Liste DolaÅŸma O(n)', action: async () => { try { await demoTraverse(linkedList); } catch (e) { console.error(e); } } },
        { name: 'BaÅŸtan Silme O(1)', action: async () => { try { await demoDelete(linkedList, 'head'); } catch (e) { console.error(e); } } },
        { name: 'Sondan Silme O(n)', action: async () => { try { await demoDelete(linkedList, 'tail'); } catch (e) { console.error(e); } } },
        { name: 'Bellek YÃ¶netimi', action: async () => { try { await showMemoryManagement(linkedList); } catch (e) { console.error(e); } } },
        { name: 'Demo TamamlandÄ±', action: async () => { try { await demoComplete(linkedList); } catch (e) { console.error(e); } } }
      ];
      
      for (let i = 0; i < linkedListOperations.length; i++) {
        setCurrentStep(i + 1);
        addLogMessage(`Demo adÄ±m ${i+1}: ${linkedListOperations[i].name}`);
        await linkedListOperations[i].action();
        linkedList = [...array]; // GÃ¼ncel listeyi al
      }
      
    } catch (error) {
      console.error("BaÄŸlÄ± Liste Demo sÄ±rasÄ±nda hata:", error);
      setExplanationText("Demo sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Demo iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // BaÅŸa ekleme (Prepend)
  const performPrepend = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen eklenecek deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(3);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let linkedList = [...array];
      
      setCurrentStep(1);
      setExplanationText(`â• BaÅŸa ${value} deÄŸeri ekleniyor...`);
      addLogMessage(`BaÅŸa ekleme iÅŸlemi: ${value}`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      setCurrentStep(2);
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next pointer'Ä± mevcut HEAD'i gÃ¶sterecek...`);
      addLogMessage(`Yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor, next pointer HEAD'i gÃ¶sterecek`);
      if (linkedList.length > 0) {
        // Mevcut head'i vurgula
        barColors.current[0].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
      }
      await wait(speed);
      
      setCurrentStep(3);
      // DeÄŸeri listeye ekle
      linkedList.unshift(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current = [new Animated.Value(0), ...barRefs.current];
      barColors.current = [new Animated.Value(2), ...barColors.current];
      
      setExplanationText(`âœ… ${value} baÅŸa eklendi! HEAD pointer artÄ±k yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steriyor. Zaman: O(1)`);
      addLogMessage(`BaÅŸa ekleme tamamlandÄ±: ${value} deÄŸeri eklendi`);
      setInputValue(''); // Input'u temizle
      
    } catch (error) {
      console.error("Prepend sÄ±rasÄ±nda hata:", error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: BaÅŸa ekleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Sona ekleme (Append)
  const performAppend = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen eklenecek deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length + 2);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let linkedList = [...array];
      
      setCurrentStep(1);
      setExplanationText(`â• Sona ${value} deÄŸeri ekleniyor...`);
      addLogMessage(`Sona ekleme iÅŸlemi: ${value}`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ bul
      for (let i = 0; i < linkedList.length; i++) {
        setCurrentStep(i + 2);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor... Son dÃ¼ÄŸÃ¼mÃ¼ arÄ±yoruz.`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} kontrol ediliyor: Son dÃ¼ÄŸÃ¼mÃ¼ arama`);
        await wait(speed / 2);
      }
      
      setCurrentStep(linkedList.length + 2);
      // DeÄŸeri listeye ekle
      linkedList.push(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.push(new Animated.Value(0));
      barColors.current.push(new Animated.Value(2));
      
      setExplanationText(`âœ… ${value} sona eklendi! Son dÃ¼ÄŸÃ¼mÃ¼n next'i yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶steriyor. Zaman: O(n)`);
      addLogMessage(`Sona ekleme tamamlandÄ±: ${value} deÄŸeri eklendi`);
      setInputValue(''); // Input'u temizle
      
    } catch (error) {
      console.error("Append sÄ±rasÄ±nda hata:", error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Sona ekleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Belirli pozisyona ekleme
  const performInsertAt = async () => {
    if (!inputValue.trim() || !insertPosition.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen deÄŸer ve pozisyon girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    const position = parseInt(insertPosition);
    
    if (isNaN(value) || isNaN(position)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli sayÄ±lar girin!');
      return;
    }
    
    if (position < 0 || position > array.length) {
      setExplanationText(`âš ï¸ Pozisyon 0-${array.length} arasÄ±nda olmalÄ±!`);
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(position + 3);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      let linkedList = [...array];
      
      setCurrentStep(1);
      setExplanationText(`ğŸ¯ ${position + 1}. pozisyona ${value} ekleniyor...`);
      addLogMessage(`Pozisyona ekleme iÅŸlemi: ${value} deÄŸeri ${position+1}. pozisyona ekleniyor`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      // Pozisyona kadar git
      for (let i = 0; i < position; i++) {
        setCurrentStep(i + 2);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼mden ${position + 1}. pozisyona gidiyoruz...`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} geÃ§iliyor: Hedef pozisyona doÄŸru`);
        await wait(speed / 2);
      }
      
      setCurrentStep(position + 2);
      if (position < linkedList.length) {
        barColors.current[position].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼m ${position + 1}. pozisyondaki dÃ¼ÄŸÃ¼mÃ¼n Ã¶nÃ¼ne eklenecek...`);
        addLogMessage(`Hedef pozisyon bulundu: ${position+1}`);
        await wait(speed);
      }
      
      setCurrentStep(position + 3);
      linkedList.splice(position, 0, value);
      setArray([...linkedList]);
      barColors.current[position].setValue(2); // Takas rengi
      setExplanationText(`âœ… ${value} deÄŸeri ${position + 1}. pozisyona eklendi! Pointer'lar gÃ¼ncellendi. Zaman: O(n)`);
      addLogMessage(`Pozisyona ekleme tamamlandÄ±: ${value} deÄŸeri ${position+1}. pozisyona eklendi`);
      setInputValue('');
      setInsertPosition('');
      
    } catch (error) {
      console.error("Insert sÄ±rasÄ±nda hata:", error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Pozisyona ekleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Arama
  const performSearch = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen aranacak deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let found = false;
      let foundIndex = -1;
      
      setExplanationText(`ğŸ” ${value} deÄŸeri aranÄ±yor...`);
      addLogMessage(`Arama iÅŸlemi: ${value} deÄŸeri aranÄ±yor`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      // SÄ±rayla arama
      for (let i = 0; i < array.length; i++) {
        setCurrentStep(i + 1);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor: ${array[i]} === ${value}?`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} kontrol ediliyor: ${array[i]} == ${value}?`);
        await wait(speed);
        
        if (array[i] === value) {
          barColors.current[i].setValue(3); // SÄ±ralanmÄ±ÅŸ rengi
          setExplanationText(`ğŸ‰ ${value} deÄŸeri ${i + 1}. pozisyonda bulundu! Zaman: O(${i + 1})`);
          addLogMessage(`BULUNDU! ${value} deÄŸeri ${i+1}. pozisyonda`);
          found = true;
          foundIndex = i;
          break;
        } else {
          // Kontrol edildi, bulunamadÄ±
          await wait(speed / 2);
          barColors.current[i].setValue(0); // Normal renk
          addLogMessage(`EÅŸleÅŸme yok: ${array[i]} != ${value}`);
        }
      }
      
      if (!found) {
        setExplanationText(`âŒ ${value} deÄŸeri listede bulunamadÄ±! Zaman: O(n)`);
        addLogMessage(`Arama tamamlandÄ±: ${value} deÄŸeri bulunamadÄ±`);
      }
      
      setInputValue('');
      
    } catch (error) {
      console.error("Search sÄ±rasÄ±nda hata:", error);
      setExplanationText("Arama sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Arama iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // BaÅŸtan silme
  const performDeleteHead = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste boÅŸ! Silinecek eleman yok.');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(3);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let linkedList = [...array];
      const deletedValue = linkedList[0];
      
      setCurrentStep(1);
      barColors.current[0].setValue(2); // Takas rengi
      setExplanationText(`ğŸ—‘ï¸ BaÅŸtan eleman siliniyor: ${deletedValue}`);
      addLogMessage(`BaÅŸtan silme iÅŸlemi: ${deletedValue} siliniyor`);
      await wait(speed);
      
      setCurrentStep(2);
      if (linkedList.length > 1) {
        barColors.current[1].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ”— HEAD pointer ikinci dÃ¼ÄŸÃ¼mÃ¼ (${linkedList[1]}) gÃ¶sterecek...`);
        addLogMessage(`HEAD pointer ikinci dÃ¼ÄŸÃ¼me yÃ¶nlendiriliyor`);
        await wait(speed);
      }
      
      setCurrentStep(3);
      // BaÅŸtan deÄŸeri kaldÄ±r
      linkedList.shift();
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.shift();
      barColors.current.shift();
      
      setArray([...linkedList]);
      
      // Kalan barlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      setExplanationText(`âœ… ${deletedValue} silindi! HEAD pointer gÃ¼ncellendi. Zaman: O(1)`);
      addLogMessage(`BaÅŸtan silme tamamlandÄ±: ${deletedValue} silindi`);
      
    } catch (error) {
      console.error("Delete head sÄ±rasÄ±nda hata:", error);
      setExplanationText("Silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: BaÅŸtan silme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Sondan silme
  const performDeleteTail = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste boÅŸ! Silinecek eleman yok.');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length + 1);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let linkedList = [...array];
      const deletedValue = linkedList[linkedList.length - 1];
      
      setExplanationText(`ğŸ—‘ï¸ Sondan eleman siliniyor: ${deletedValue}`);
      addLogMessage(`Sondan silme iÅŸlemi: ${deletedValue} siliniyor`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      // Son elemandan Ã¶nceki elemana git
      for (let i = 0; i < linkedList.length - 1; i++) {
        setCurrentStep(i + 1);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m: Son elemandan Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ arÄ±yoruz...`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} kontrol ediliyor: Son elemandan Ã¶nceki aranÄ±yor`);
        await wait(speed / 2);
      }
      
      setCurrentStep(linkedList.length);
      barColors.current[linkedList.length - 1].setValue(2); // Takas rengi
      setExplanationText(`ğŸ”— Son dÃ¼ÄŸÃ¼mÃ¼n baÄŸlantÄ±sÄ± koparÄ±lÄ±yor...`);
      addLogMessage(`Son dÃ¼ÄŸÃ¼m bulundu: BaÄŸlantÄ± koparÄ±lÄ±yor`);
      await wait(speed);
      
      setCurrentStep(linkedList.length + 1);
      // Sondan deÄŸeri kaldÄ±r
      linkedList.pop();
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.pop();
      barColors.current.pop();
      
      setArray([...linkedList]);
      
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      setExplanationText(`âœ… ${deletedValue} silindi! Ã–nceki dÃ¼ÄŸÃ¼mÃ¼n next'i NULL olarak ayarlandÄ±. Zaman: O(n)`);
      addLogMessage(`Sondan silme tamamlandÄ±: ${deletedValue} silindi`);
      
    } catch (error) {
      console.error("Delete tail sÄ±rasÄ±nda hata:", error);
      setExplanationText("Silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Sondan silme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Belirli deÄŸer silme
  const performDeleteValue = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen silinecek deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      let linkedList = [...array];
      let found = false;
      
      setExplanationText(`ğŸ—‘ï¸ ${value} deÄŸeri aranÄ±p siliniyor...`);
      addLogMessage(`DeÄŸer silme iÅŸlemi: ${value} aranÄ±yor`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      // DeÄŸeri ara ve sil
      for (let i = 0; i < linkedList.length; i++) {
        setCurrentStep(i + 1);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor: ${linkedList[i]} === ${value}?`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} kontrol ediliyor: ${linkedList[i]} == ${value}?`);
        await wait(speed);
        
        if (linkedList[i] === value) {
          barColors.current[i].setValue(2); // Takas rengi
          setExplanationText(`ğŸ—‘ï¸ ${value} bulundu! DÃ¼ÄŸÃ¼m siliniyor...`);
          addLogMessage(`BULUNDU! ${value} deÄŸeri ${i+1}. pozisyonda siliniyor`);
          await wait(speed);
          
          // DeÄŸeri listeden kaldÄ±r
          linkedList.splice(i, 1);
          
          // Animasyon deÄŸerlerini gÃ¼ncelle
          barRefs.current.splice(i, 1);
          barColors.current.splice(i, 1);
          
          setArray([...linkedList]);
          setExplanationText(`âœ… ${value} silindi! Ã–nceki dÃ¼ÄŸÃ¼mÃ¼n pointer'Ä± gÃ¼ncellenidi. Zaman: O(n)`);
          addLogMessage(`DeÄŸer silme tamamlandÄ±: ${value} silindi`);
          found = true;
          break;
        }
      }
      
      if (!found) {
        setExplanationText(`âŒ ${value} deÄŸeri listede bulunamadÄ±!`);
        addLogMessage(`DeÄŸer silme tamamlandÄ±: ${value} deÄŸeri bulunamadÄ±`);
      }
      
      setInputValue('');
      
    } catch (error) {
      console.error("Delete value sÄ±rasÄ±nda hata:", error);
      setExplanationText("Silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: DeÄŸer silme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Renk deÄŸerlerini animasyonlu renklere dÃ¶nÃ¼ÅŸtÃ¼r
  const getBarColor = (index: number) => {
    // barColors.current[index] deÄŸeri henÃ¼z yoksa veya tanÄ±msÄ±zsa yeni bir deÄŸer oluÅŸtur
    if (!barColors.current || !barColors.current[index]) {
      // Eksik deÄŸer varsa dÃ¼zelt
      if (!barColors.current) {
        barColors.current = [];
      }
      if (!barColors.current[index]) {
        barColors.current[index] = new Animated.Value(0);
      }
      return normalColor; // VarsayÄ±lan renk dÃ¶ndÃ¼r
    }
    
    return barColors.current[index].interpolate({
      inputRange: [0, 1, 2, 3],
      outputRange: [normalColor, comparingColor, swappingColor, sortedColor],
    });
  };
  
  // Ä°ki barÄ±n yerinin deÄŸiÅŸmesini animasyonla gÃ¶ster
  const animateSwap = (index1: number, index2: number, delay: number = 0): Promise<void> => {
    const bar1Position = index1 * (BAR_WIDTH + BAR_MARGIN);
    const bar2Position = index2 * (BAR_WIDTH + BAR_MARGIN);
    const distance = bar2Position - bar1Position;
    
    return new Promise<void>((resolve) => {
      // Referanslar hazÄ±r deÄŸilse iÅŸlemi sonlandÄ±r
      if (!barRefs.current || !barColors.current || 
          !barRefs.current[index1] || !barRefs.current[index2] ||
          !barColors.current[index1] || !barColors.current[index2]) {
        console.warn(`animateSwap: GeÃ§ersiz indeksler (${index1}, ${index2}) veya referanslar hazÄ±r deÄŸil`);
        resolve();
        return;
      }
      
      // KarÅŸÄ±laÅŸtÄ±rma rengini ayarla
      Animated.timing(barColors.current[index1], {
        toValue: 1, // Turuncu - karÅŸÄ±laÅŸtÄ±rma
        duration: speed / 3,
        useNativeDriver: false,
      }).start();
      
      Animated.timing(barColors.current[index2], {
        toValue: 1, // Turuncu - karÅŸÄ±laÅŸtÄ±rma
        duration: speed / 3,
        useNativeDriver: false,
      }).start();
      
      setTimeout(() => {
        // Takas rengini ayarla
        Animated.timing(barColors.current[index1], {
          toValue: 2, // KÄ±rmÄ±zÄ± - takas
          duration: speed / 3,
          useNativeDriver: false,
        }).start();
        
        Animated.timing(barColors.current[index2], {
          toValue: 2, // KÄ±rmÄ±zÄ± - takas
          duration: speed / 3,
          useNativeDriver: false,
        }).start();
        
        // Bar 1'i saÄŸa taÅŸÄ±
        Animated.timing(barRefs.current[index1], {
          toValue: distance,
          duration: speed,
          useNativeDriver: false,
        }).start();
        
        // Bar 2'yi sola taÅŸÄ±
        Animated.timing(barRefs.current[index2], {
          toValue: -distance,
          duration: speed,
          useNativeDriver: false,
        }).start();
        
        // Animasyon tamamlandÄ±ktan sonra referanslarÄ± sÄ±fÄ±rla
        setTimeout(() => {
          barRefs.current[index1].setValue(0);
          barRefs.current[index2].setValue(0);
          
          // Normal renklere geri dÃ¶n
          Animated.timing(barColors.current[index1], {
            toValue: 0, // Normal renk
            duration: speed / 3,
            useNativeDriver: false,
          }).start();
          
          Animated.timing(barColors.current[index2], {
            toValue: 0, // Normal renk
            duration: speed / 3,
            useNativeDriver: false,
          }).start();
          
          resolve();
        }, speed);
      }, speed / 3);
    });
  };
  
  // Renkleri animasyonla deÄŸiÅŸtir
  const animateColor = (index: number, colorValue: number, duration: number = speed / 2): Promise<void> => {
    return new Promise<void>((resolve) => {
      // index geÃ§erli bir aralÄ±kta deÄŸilse ya da barColors henÃ¼z hazÄ±r deÄŸilse
      if (!barColors.current || !barColors.current[index]) {
        console.warn(`animateColor: GeÃ§ersiz index (${index}) veya barColors hazÄ±r deÄŸil`);
        resolve(); // Ä°ÅŸlemi sonlandÄ±r
        return;
      }
      
      Animated.timing(barColors.current[index], {
        toValue: colorValue,
        duration,
        useNativeDriver: false,
      }).start(() => {
        resolve();
      });
    });
  };
  
  // Algoritma tipine gÃ¶re doÄŸru gÃ¶rselleÅŸtirmeyi Ã§aÄŸÄ±r
  const startVisualization = () => {
    if (sorting) return;
    
    // TÃ¼m renkleri sÄ±fÄ±rla
    if (barColors.current) {
      barColors.current.forEach((color, index) => {
        if (color) {
          color.setValue(0);
        }
      });
    }
    
    // BaÄŸlÄ± liste algoritmalarÄ± iÃ§in
    if (algorithmType.toLowerCase().includes('linked') || 
        algorithmType.toLowerCase().includes('baÄŸlÄ± liste') || 
        algorithmType.toLowerCase().includes('dairesel')) {
      
      console.log('Starting linked list visualization for operation:', selectedOperation);
      
      // BaÄŸlÄ± liste tipine gÃ¶re doÄŸru gÃ¶rselleÅŸtirmeyi Ã§aÄŸÄ±r
      if (algorithmType.toLowerCase().includes('doubly') || 
          algorithmType.toLowerCase().includes('Ã§ift')) {
        visualizeDoublyLinkedList();
      } else if (algorithmType.toLowerCase().includes('circular') ||
                algorithmType.toLowerCase().includes('dairesel')) {
        // Dairesel baÄŸlÄ± liste iÃ§in gÃ¶rselleÅŸtirme
        visualizeCircularLinkedList();
      } else {
        // Tek yÃ¶nlÃ¼ baÄŸlÄ± liste iÃ§in
        visualizeSinglyLinkedList();
      }
      return;
    }
    
    switch (algorithmType.toLowerCase()) {
      case 'bubble sort':
      case 'kabarcÄ±k sÄ±ralama':
      case 'kabarcÄ±k sÄ±ralamasÄ±':
        visualizeBubbleSort();
        break;
      case 'binary search':
      case 'ikili arama':
      case 'binary arama':
        // Instead of displaying a message, call the visualizeBinarySearch function
        visualizeBinarySearch();
        break;
      case 'merge sort':
      case 'birleÅŸtirme sÄ±ralamasÄ±':
      case 'merge sÄ±ralama':
        visualizeMergeSort();
        break;
      case 'quick sort':
      case 'hÄ±zlÄ± sÄ±ralama':
      case 'quicksort':
        visualizeQuickSort();
        break;
      case 'linear search':
      case 'doÄŸrusal arama':
      case 'sÄ±ralÄ± arama':
        visualizeLinearSearch();
        break;
      case 'selection sort':
      case 'seÃ§im sÄ±ralamasÄ±':
      case 'seÃ§meli sÄ±ralama':
        visualizeSelectionSort();
        break;
      case 'insertion sort':
      case 'ekleme sÄ±ralamasÄ±':
      case 'yerleÅŸtirme sÄ±ralamasÄ±':
        visualizeInsertionSort();
        break;
      case 'heap sort':
      case 'yÄ±ÄŸÄ±n sÄ±ralamasÄ±':
        visualizeHeapSort();
        break;
      case 'counting sort':
      case 'sayma sÄ±ralamasÄ±':
        visualizeCountingSort();
        break;
      case 'radix sort':
      case 'taban sÄ±ralamasÄ±':
        visualizeRadixSort();
        break;
      case 'shell sort':
      case 'kabuk sÄ±ralamasÄ±':
        visualizeShellSort();
        break;
      default:
        setExplanationText(`${algorithmType} algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme henÃ¼z uygulanmadÄ±. Mevcut algoritmalar: Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort, Linear Search, Binary Search, Singly Linked List, Doubly Linked List, Circular Linked List`);
        break;
    }
  };
  
  // Linear Search algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeLinearSearch = async () => {
    if (sorting) return;
    
    // Hedef deÄŸeri kontrol et
    if (!searchTarget.trim()) {
      Alert.alert('Hata', 'LÃ¼tfen aranacak sayÄ±yÄ± girin.');
      return;
    }
    
    const target = parseInt(searchTarget.trim());
    if (isNaN(target)) {
      Alert.alert('Hata', 'LÃ¼tfen geÃ§erli bir sayÄ± girin.');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    
    const arr = [...array];
    const n = arr.length;
    
    setExplanationText(`Linear Search: ${target} deÄŸeri aranÄ±yor.`);
    
    // AdÄ±m sayÄ±sÄ±nÄ± belirle
    setTotalSteps(n);
    
    let found = false;
    
    try {
    // Diziyi soldan saÄŸa tarama
    for (let i = 0; i < n; i++) {
      // Mevcut elemanÄ± vurgula
      setCurrentStep(i + 1);
      setExplanationText(`AdÄ±m ${i + 1}: ${arr[i]} elemanÄ± kontrol ediliyor...`);
      
      // ElemanÄ± vurgula
      await animateColor(i, 1, 300);
      
      if (arr[i] === target) {
        // Eleman bulundu
        setExplanationText(`${target} deÄŸeri ${i}. indekste bulundu!`);
        await animateColor(i, 3, 500); // Bulunan eleman yeÅŸil renkte vurgulanÄ±r
        found = true;
        break;
      }
      
      // Eleman bulunamadÄ±, bir sonraki elemana geÃ§
      await animateColor(i, 0, 200);
    }
    
    if (!found) {
      setExplanationText(`${target} deÄŸeri dizide bulunamadÄ±.`);
    }
    } catch (error) {
      console.error("Linear Search sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
    setSorting(false);
    }
  };
  
  // Binary Search algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeBinarySearch = async () => {
    if (sorting) return;
    
    // Hedef deÄŸeri kontrol et
    if (!searchTarget.trim()) {
      Alert.alert('Hata', 'LÃ¼tfen aranacak sayÄ±yÄ± girin.');
      return;
    }
    
    const target = parseInt(searchTarget.trim());
    if (isNaN(target)) {
      Alert.alert('Hata', 'LÃ¼tfen geÃ§erli bir sayÄ± girin.');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    
    // Binary search sÄ±ralanmÄ±ÅŸ dizi gerektirir
    const sortedArray = [...array].sort((a, b) => a - b);
    setArray(sortedArray);
    
    const n = sortedArray.length;
    
    setExplanationText(`Binary Search: ${target} deÄŸeri aranÄ±yor. Binary Search sÄ±ralanmÄ±ÅŸ bir dizi gerektirir.`);
    
    let left = 0;
    let right = n - 1;
    let found = false;
    let foundIndex = -1;
    let stepCount = 0;
    
    // Toplam adÄ±m sayÄ±sÄ±nÄ± hesapla (worst case)
    setTotalSteps(Math.ceil(Math.log2(n)));
    
    try {
      while (left <= right) {
        stepCount++;
        setCurrentStep(stepCount);
        
        // Mevcut arama aralÄ±ÄŸÄ±nÄ± vurgula
        for (let i = 0; i < n; i++) {
          if (i < left || i > right) {
            await animateColor(i, 0, 200); // Arama aralÄ±ÄŸÄ± dÄ±ÅŸÄ±
          } else {
            await animateColor(i, 1, 200); // Arama aralÄ±ÄŸÄ± iÃ§i
          }
        }
        
        // Ortadaki elemanÄ± hesapla
        const mid = Math.floor((left + right) / 2);
        
        setExplanationText(`AdÄ±m ${stepCount}: Sol=${left}, SaÄŸ=${right}, Orta=${mid}, DeÄŸer=${sortedArray[mid]}`);
        
        // Ortadaki elemanÄ± vurgula
        await animateColor(mid, 2, 500);
        
        // Kontrol et
        if (sortedArray[mid] === target) {
          // Hedef bulundu
          setExplanationText(`${target} deÄŸeri ${mid}. indekste bulundu!`);
          await animateColor(mid, 3, 1000); // Bulunan eleman yeÅŸil renkte
          found = true;
          foundIndex = mid;
          break;
        } else if (sortedArray[mid] < target) {
          // SaÄŸ tarafta arama yap
          setExplanationText(`${sortedArray[mid]} < ${target}, saÄŸ tarafta aranacak`);
          
          // Sol tarafÄ± devre dÄ±ÅŸÄ± bÄ±rak
          for (let i = left; i <= mid; i++) {
            await animateColor(i, 0, 100);
          }
          
          left = mid + 1;
        } else {
          // Sol tarafta arama yap
          setExplanationText(`${sortedArray[mid]} > ${target}, sol tarafta aranacak`);
          
          // SaÄŸ tarafÄ± devre dÄ±ÅŸÄ± bÄ±rak
          for (let i = mid; i <= right; i++) {
            await animateColor(i, 0, 100);
          }
          
          right = mid - 1;
        }
        
        await new Promise(resolve => setTimeout(resolve, speed / 2));
      }
      
      if (!found) {
        setExplanationText(`${target} deÄŸeri dizide bulunamadÄ±.`);
      }
      
      // Verimlilik hesaplama
      const maxSteps = Math.ceil(Math.log2(n));
      const efficiency = found ? Math.round((maxSteps / stepCount) * 100) : 0;
      
      setExplanationText(found 
        ? `âœ… Binary Search tamamlandÄ±! Hedef ${stepCount}. adÄ±mda bulundu. Teorik maksimum adÄ±m: ${maxSteps}. Verimlilik: %${efficiency}`
        : `âŒ Binary Search tamamlandÄ±! Hedef ${stepCount} adÄ±mda bulunamadÄ±ÄŸÄ± kesinleÅŸti. Teorik maksimum adÄ±m: ${maxSteps}`
      );
      
    } catch (error) {
      console.error("Binary Search sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Selection Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeSelectionSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    try {
      const newArray = [...array];
      const n = newArray.length;
      let totalSwaps = 0;
      let totalComparisons = 0;
      
      // Toplam adÄ±m sayÄ±sÄ±nÄ± hesapla
      setTotalSteps(n - 1);
      
      setExplanationText('Selection Sort algoritmasÄ± baÅŸlatÄ±lÄ±yor. Her adÄ±mda kalan elemanlar arasÄ±ndan en kÃ¼Ã§Ã¼ÄŸÃ¼nÃ¼ bulup doÄŸru pozisyona yerleÅŸtirir.');
      
      for (let i = 0; i < n - 1; i++) {
        let minIndex = i;
        setCurrentStep(i + 1);
        setExplanationText(`${i + 1}. geÃ§iÅŸ: ${i + 1}. pozisyon iÃ§in en kÃ¼Ã§Ã¼k eleman aranÄ±yor...`);
        
        // Mevcut minimum elemanÄ± vurgula
        await animateColor(minIndex, 1);
        await new Promise(resolve => setTimeout(resolve, speed / 3));
        
        for (let j = i + 1; j < n; j++) {
          totalComparisons++;
          
          // KarÅŸÄ±laÅŸtÄ±rÄ±lan elemanÄ± vurgula
          await animateColor(j, 2);
          setExplanationText(`Minimum ${newArray[minIndex]} ile ${newArray[j]} karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor... (${totalComparisons}. karÅŸÄ±laÅŸtÄ±rma)`);
          
          await new Promise(resolve => setTimeout(resolve, speed / 2));
          
          if (newArray[j] < newArray[minIndex]) {
            // Ã–nceki minimum elemanÄ± normal renge dÃ¶ndÃ¼r
            await animateColor(minIndex, 0);
            minIndex = j;
            // Yeni minimum elemanÄ± vurgula
            await animateColor(minIndex, 1);
            setExplanationText(`Yeni minimum bulundu: ${newArray[minIndex]} (pozisyon ${j + 1})`);
            await new Promise(resolve => setTimeout(resolve, speed / 3));
          }
          
          // KarÅŸÄ±laÅŸtÄ±rÄ±lan elemanÄ± normal renge dÃ¶ndÃ¼r
          await animateColor(j, 0);
        }
        
        // Minimum elemanÄ± doÄŸru pozisyona taÅŸÄ±
        if (minIndex !== i) {
          totalSwaps++;
          
          // Takas animasyonu
          await Promise.all([
            animateColor(i, 2),
            animateColor(minIndex, 2),
          ]);
          
          setExplanationText(`${newArray[i]} ile ${newArray[minIndex]} takas ediliyor... (${totalSwaps}. takas)`);
          
          await new Promise(resolve => setTimeout(resolve, speed / 3));
          
          // DeÄŸerleri takas et
          const temp = newArray[i];
          newArray[i] = newArray[minIndex];
          newArray[minIndex] = temp;
          
          // Takas animasyonunu gÃ¶ster
          await animateSwap(i, minIndex);
          
          // Diziyi gÃ¼ncelle
          setArray([...newArray]);
          
          await new Promise(resolve => setTimeout(resolve, speed / 4));
        } else {
          setExplanationText(`${newArray[i]} zaten doÄŸru pozisyonda, takas gerekmiyor.`);
          await new Promise(resolve => setTimeout(resolve, speed / 3));
        }
        
        // SÄ±ralanmÄ±ÅŸ elemanÄ± iÅŸaretle
        await animateColor(i, 3);
        setExplanationText(`${i + 1}. geÃ§iÅŸ tamamlandÄ±. ${newArray[i]} doÄŸru konumuna yerleÅŸti.`);
        
        // GeÃ§iÅŸler arasÄ± kÄ±sa bekle
        await new Promise(resolve => setTimeout(resolve, speed / 3));
      }
      
      // Son elemanÄ± da sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      await animateColor(n - 1, 3);
      
      setExplanationText(`Selection Sort tamamlandÄ±! Toplam ${totalSwaps} takas ve ${totalComparisons} karÅŸÄ±laÅŸtÄ±rma yapÄ±ldÄ±. Dizi baÅŸarÄ±yla sÄ±ralandÄ±.`);
    } catch (error) {
      console.error("Selection Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.");
    } finally {
      setSorting(false);
    }
  };
  
  // Insertion Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeInsertionSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    const arr = [...array];
    const n = arr.length;
    let stepCount = 0;
    const steps = n * (n - 1) / 2; // Worst case adÄ±m sayÄ±sÄ± tahmini
    setTotalSteps(steps);
    
    setExplanationText('Insertion Sort, sÄ±ralanmÄ±ÅŸ alt dizi oluÅŸturarak her yeni elemanÄ± doÄŸru konuma yerleÅŸtirir.');
    
    // Ä°lk eleman baÅŸlangÄ±Ã§ta sÄ±ralanmÄ±ÅŸ kabul edilir
    await animateColor(0, 3);
    
    for (let i = 1; i < n; i++) {
      // Åu anki elemanÄ± vurgula
      await animateColor(i, 2);
      setExplanationText(`${arr[i]} elemanÄ± sÄ±ralanmÄ±ÅŸ alt diziye yerleÅŸtirilecek.`);
      await new Promise(resolve => setTimeout(resolve, speed));
      
      // Mevcut elemanÄ± key olarak al
      const key = arr[i];
      let j = i - 1;
      
      // key'den bÃ¼yÃ¼k olan elemanlarÄ± bir pozisyon saÄŸa kaydÄ±r
      while (j >= 0 && arr[j] > key) {
        stepCount++;
        setCurrentStep(stepCount);
        
        // KarÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±yor
        setExplanationText(`AdÄ±m ${stepCount}: ${arr[j]} > ${key}, ${arr[j]} elemanÄ± saÄŸa kaydÄ±rÄ±lÄ±yor`);
        
        // ElemanÄ± vurgula
        await animateColor(j, 1);
        
        // ElemanÄ± bir saÄŸa kaydÄ±r
        arr[j + 1] = arr[j];
        
        // KaydÄ±rma animasyonunu gÃ¶ster (saÄŸa kaydÄ±rma)
        await animateSwap(j, j + 1);
        
        // Diziyi gÃ¼ncelle
        setArray([...arr]);
        
        j--;
      }
      
      // DoÄŸru konuma yerleÅŸtir
      arr[j + 1] = key;
      
      // SÄ±raya giren elemanlarÄ± iÅŸaretle
      for (let k = 0; k <= i; k++) {
        await animateColor(k, 3);
      }
    }
    
    setExplanationText('Insertion Sort tamamlandÄ±! Dizi sÄ±ralandÄ±.');
    setSorting(false);
  };

  // Heap Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeHeapSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    try {
      const arr = [...array];
      const n = arr.length;
      let stepCount = 0;
      setTotalSteps(n * Math.log2(n));
      
      setExplanationText('Heap Sort algoritmasÄ± baÅŸlatÄ±lÄ±yor. Ã–nce max heap oluÅŸturulacak, sonra elemanlar tek tek Ã§Ä±karÄ±lacak.');
      
      // Max heap oluÅŸtur
      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        await heapify(arr, n, i, stepCount);
        stepCount++;
        setCurrentStep(stepCount);
      }
      
      setExplanationText('Max heap oluÅŸturuldu. Åimdi elemanlar tek tek Ã§Ä±karÄ±lacak.');
      
      // ElemanlarÄ± tek tek Ã§Ä±kar
      for (let i = n - 1; i > 0; i--) {
        // KÃ¶k ile son elemanÄ± takas et
        await Promise.all([
          animateColor(0, 2),
          animateColor(i, 2),
        ]);
        
        setExplanationText(`En bÃ¼yÃ¼k eleman ${arr[0]} son pozisyona taÅŸÄ±nÄ±yor...`);
        
        const temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        
        await animateSwap(0, i);
        setArray([...arr]);
        
        // SÄ±ralanmÄ±ÅŸ elemanÄ± iÅŸaretle
        await animateColor(i, 3);
        
        // Kalan heap'i dÃ¼zenle
        await heapify(arr, i, 0, stepCount);
        stepCount++;
        setCurrentStep(stepCount);
      }
      
      // Ä°lk elemanÄ± da sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      await animateColor(0, 3);
      
      setExplanationText('Heap Sort tamamlandÄ±! Dizi baÅŸarÄ±yla sÄ±ralandÄ±.');
    } catch (error) {
      console.error("Heap Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.");
    } finally {
      setSorting(false);
    }
  };
  
  // Heapify yardÄ±mcÄ± fonksiyonu
  const heapify = async (arr: number[], n: number, i: number, stepCount: number) => {
    let largest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;
    
    // Sol Ã§ocuk kÃ¶kten bÃ¼yÃ¼kse
    if (left < n && arr[left] > arr[largest]) {
      largest = left;
    }
    
    // SaÄŸ Ã§ocuk ÅŸu anki en bÃ¼yÃ¼kten bÃ¼yÃ¼kse
    if (right < n && arr[right] > arr[largest]) {
      largest = right;
    }
    
    // En bÃ¼yÃ¼k kÃ¶k deÄŸilse
    if (largest !== i) {
      await Promise.all([
        animateColor(i, 1),
        animateColor(largest, 1),
      ]);
      
      const temp = arr[i];
      arr[i] = arr[largest];
      arr[largest] = temp;
      
      await animateSwap(i, largest);
      
      // Etkilenen alt aÄŸacÄ± da dÃ¼zenle
      await heapify(arr, n, largest, stepCount);
    }
  };

  // Counting Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeCountingSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    try {
      const arr = [...array];
      const n = arr.length;
      const max = Math.max(...arr);
      const min = Math.min(...arr);
      const range = max - min + 1;
      
      setTotalSteps(n + range);
      setExplanationText(`Counting Sort baÅŸlatÄ±lÄ±yor. DeÄŸer aralÄ±ÄŸÄ±: ${min}-${max}`);
      
      // Sayma dizisini oluÅŸtur
      const count = new Array(range).fill(0);
      
      // Her elemanÄ±n sayÄ±sÄ±nÄ± say
      for (let i = 0; i < n; i++) {
        await animateColor(i, 1);
        count[arr[i] - min]++;
        setExplanationText(`${arr[i]} deÄŸeri sayÄ±lÄ±yor... (${count[arr[i] - min]}. kez)`);
        setCurrentStep(i + 1);
        await new Promise(resolve => setTimeout(resolve, speed / 2));
        await animateColor(i, 0);
      }
      
      setExplanationText('Sayma tamamlandÄ±. Åimdi sÄ±ralÄ± dizi oluÅŸturuluyor...');
      
      // SÄ±ralÄ± diziyi oluÅŸtur
      const sortedArr = [];
      let step = n;
      
      for (let i = 0; i < range; i++) {
        while (count[i] > 0) {
          sortedArr.push(i + min);
          count[i]--;
          step++;
          setCurrentStep(step);
        }
      }
      
      // Diziyi gÃ¼ncelle ve animasyon gÃ¶ster
      for (let i = 0; i < n; i++) {
        arr[i] = sortedArr[i];
        await animateColor(i, 3);
        setArray([...arr]);
        await new Promise(resolve => setTimeout(resolve, speed / 3));
      }
      
      setExplanationText('Counting Sort tamamlandÄ±! Dizi O(n+k) zamanda sÄ±ralandÄ±.');
    } catch (error) {
      console.error("Counting Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.");
    } finally {
      setSorting(false);
    }
  };

  // Radix Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeRadixSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    try {
      const arr = [...array];
      const n = arr.length;
      const max = Math.max(...arr);
      
      // Maksimum basamak sayÄ±sÄ±nÄ± bul
      const maxDigits = max.toString().length;
      setTotalSteps(maxDigits * n);
      
      setExplanationText(`Radix Sort baÅŸlatÄ±lÄ±yor. Maksimum ${maxDigits} basamak iÅŸlenecek.`);
      
      // Her basamak iÃ§in counting sort uygula
      for (let digit = 0; digit < maxDigits; digit++) {
        setExplanationText(`${digit + 1}. basamak (${Math.pow(10, digit)}ler) iÅŸleniyor...`);
        
        await countingSortByDigit(arr, digit);
        
        // Ara sonucu gÃ¶ster
        for (let i = 0; i < n; i++) {
          await animateColor(i, 1);
          await new Promise(resolve => setTimeout(resolve, speed / 4));
          await animateColor(i, 0);
        }
      }
      
      // TÃ¼m elemanlarÄ± sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      for (let i = 0; i < n; i++) {
        await animateColor(i, 3);
      }
      
      setExplanationText('Radix Sort tamamlandÄ±! Dizi basamak basamak sÄ±ralandÄ±.');
    } catch (error) {
      console.error("Radix Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.");
    } finally {
      setSorting(false);
    }
  };
  
  // Belirli bir basamaÄŸa gÃ¶re counting sort
  const countingSortByDigit = async (arr: number[], digit: number) => {
    const n = arr.length;
    const output = new Array(n);
    const count = new Array(10).fill(0);
    
    // Basamak deÄŸerlerini say
    for (let i = 0; i < n; i++) {
      const digitValue = Math.floor(arr[i] / Math.pow(10, digit)) % 10;
      count[digitValue]++;
    }
    
    // KÃ¼mÃ¼latif sayÄ±larÄ± hesapla
    for (let i = 1; i < 10; i++) {
      count[i] += count[i - 1];
    }
    
    // Ã‡Ä±ktÄ± dizisini oluÅŸtur
    for (let i = n - 1; i >= 0; i--) {
      const digitValue = Math.floor(arr[i] / Math.pow(10, digit)) % 10;
      output[count[digitValue] - 1] = arr[i];
      count[digitValue]--;
    }
    
    // Orijinal diziye kopyala
    for (let i = 0; i < n; i++) {
      arr[i] = output[i];
    }
    
    setArray([...arr]);
  };

  // Shell Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeShellSort = async () => {
    if (sorting) return;
    setSorting(true);
    setCurrentStep(0);
    
    try {
      const arr = [...array];
      const n = arr.length;
      let stepCount = 0;
      
      setTotalSteps(n * Math.log2(n));
      setExplanationText('Shell Sort baÅŸlatÄ±lÄ±yor. Azalan aralÄ±klarla insertion sort uygulanacak.');
      
      // AralÄ±ÄŸÄ± n/2'den baÅŸlat ve her seferinde yarÄ±ya bÃ¶l
      for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
        setExplanationText(`AralÄ±k: ${gap} - Bu aralÄ±kla insertion sort uygulanÄ±yor...`);
        
        // Gap kadar aralÄ±klÄ± insertion sort
        for (let i = gap; i < n; i++) {
          const temp = arr[i];
          let j = i;
          
          await animateColor(i, 2);
          setExplanationText(`${temp} elemanÄ± ${gap} aralÄ±klÄ± sÄ±ralamada yerleÅŸtiriliyor...`);
          
          while (j >= gap && arr[j - gap] > temp) {
            stepCount++;
            setCurrentStep(stepCount);
            
            await Promise.all([
              animateColor(j, 1),
              animateColor(j - gap, 1),
            ]);
            
            arr[j] = arr[j - gap];
            await animateSwap(j - gap, j);
            setArray([...arr]);
            
            j -= gap;
            
            await Promise.all([
              animateColor(j + gap, 0),
              animateColor(j, 0),
            ]);
          }
          
          arr[j] = temp;
          await animateColor(i, 0);
          setArray([...arr]);
        }
        
        setExplanationText(`AralÄ±k ${gap} tamamlandÄ±.`);
        await new Promise(resolve => setTimeout(resolve, speed));
      }
      
      // TÃ¼m elemanlarÄ± sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      for (let i = 0; i < n; i++) {
        await animateColor(i, 3);
      }
      
      setExplanationText('Shell Sort tamamlandÄ±! Dizi azalan aralÄ±klarla sÄ±ralandÄ±.');
    } catch (error) {
      console.error("Shell Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.");
    } finally {
      setSorting(false);
    }
  };
  
  // Traverse
  const performTraverse = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste boÅŸ! DolaÅŸÄ±lacak eleman yok.');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      setExplanationText('ğŸš¶â€â™‚ï¸ Liste baÅŸtan sona dolaÅŸÄ±lÄ±yor...');
      addLogMessage('Liste dolaÅŸma iÅŸlemi baÅŸlatÄ±ldÄ±');
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      for (let i = 0; i < array.length; i++) {
        setCurrentStep(i + 1);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (burada ziyaret rengi olarak)
        setExplanationText(`ğŸš¶â€â™‚ï¸ ${i + 1}. dÃ¼ÄŸÃ¼m ziyaret ediliyor: ${array[i]}`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${array[i]}`);
        await wait(speed);
        
        // Bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ normal renge dÃ¶ndÃ¼r (geÃ§ildi)
        if (i > 0) {
          barColors.current[i-1].setValue(0);
        }
      }
      
      // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
      barColors.current.forEach(color => color.setValue(3));
      setExplanationText(`âœ… TÃ¼m liste dolaÅŸÄ±ldÄ±! ${array.length} dÃ¼ÄŸÃ¼m ziyaret edildi. Zaman: O(n)`);
      addLogMessage(`Liste dolaÅŸma tamamlandÄ±: ${array.length} dÃ¼ÄŸÃ¼m ziyaret edildi`);
      
    } catch (error) {
      console.error("Traverse sÄ±rasÄ±nda hata:", error);
      setExplanationText("DolaÅŸma sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Liste dolaÅŸma iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Listeyi temizle
  const performClear = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste zaten boÅŸ!');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(1);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      setCurrentStep(1);
      setExplanationText('ğŸ—‘ï¸ TÃ¼m liste temizleniyor...');
      addLogMessage('Liste temizleme iÅŸlemi baÅŸlatÄ±ldÄ±');
      // TÃ¼m barlarÄ± takas rengi yap (siliniyor)
      barColors.current.forEach(color => color.setValue(2));
      await wait(speed);
      
      setArray([]);
      setExplanationText('âœ… Liste tamamen temizlendi! HEAD pointer NULL olarak ayarlandÄ±.');
      addLogMessage('Liste temizleme tamamlandÄ±: TÃ¼m dÃ¼ÄŸÃ¼mler silindi');
      
    } catch (error) {
      console.error("Clear sÄ±rasÄ±nda hata:", error);
      setExplanationText("Temizleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Liste temizleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Demo yardÄ±mcÄ± fonksiyonlarÄ±
  const explainStructure = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    setExplanationText('ğŸ“‹ BaÄŸlÄ± Liste YapÄ±sÄ±: Her dÃ¼ÄŸÃ¼m bir veri ve bir sonraki dÃ¼ÄŸÃ¼me iÅŸaret eden pointer iÃ§erir.');
    addLogMessage('BaÄŸlÄ± liste yapÄ±sÄ± aÃ§Ä±klanÄ±yor');
    await wait(speed);
    
    if (linkedList.length > 0) {
      // TÃ¼m dÃ¼ÄŸÃ¼mleri vurgula
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(1);
      });
      setExplanationText(`ğŸ”— DÃ¼ÄŸÃ¼mler: [${linkedList.map((val, i) => `${val}â†’`).join('')}NULL] - Son dÃ¼ÄŸÃ¼m NULL'Ä± gÃ¶sterir.`);
      addLogMessage(`Liste yapÄ±sÄ±: [${linkedList.join('â†’')}â†’NULL]`);
      await wait(speed);
    }
  };
  
  const showHeadPointer = async (linkedList: number[]) => {
    if (linkedList.length > 0) {
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      // Head'i vurgula
      if (barColors.current[0]) {
        barColors.current[0].setValue(1);
      }
      setExplanationText(`ğŸ‘† HEAD pointer ilk dÃ¼ÄŸÃ¼mÃ¼ (${linkedList[0]}) iÅŸaret ediyor.`);
      addLogMessage(`HEAD pointer ${linkedList[0]} deÄŸerini gÃ¶steriyor`);
      await wait(speed);
    }
  };
  
  const demoInsert = async (linkedList: number[], position: 'head' | 'tail') => {
    const value = Math.floor(Math.random() * 100) + 1;
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    if (position === 'head') {
      setExplanationText(`â• BaÅŸa Ekleme: Yeni dÃ¼ÄŸÃ¼m (${value}) oluÅŸturuluyor...`);
      addLogMessage(`BaÅŸa ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i mevcut HEAD'i gÃ¶sterecek...`);
      if (linkedList.length > 0 && barColors.current[0]) {
        barColors.current[0].setValue(1); // Head'i vurgula
      }
      await wait(speed / 2);
      
      linkedList.unshift(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current = [new Animated.Value(0), ...barRefs.current];
      barColors.current = [new Animated.Value(2), ...barColors.current];
      
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Yeni head'i vurgula
      }
      setExplanationText(`âœ… ${value} baÅŸa eklendi! HEAD pointer gÃ¼ncellendi. Zaman: O(1)`);
      addLogMessage(`BaÅŸa ekleme tamamlandÄ±: ${value} eklendi`);
    } else {
      setExplanationText(`â• Sona Ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Sona ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ” Son dÃ¼ÄŸÃ¼mÃ¼ bulmak iÃ§in listede dolaÅŸÄ±yoruz... O(n)`);
      // Son dÃ¼ÄŸÃ¼me kadar git
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1);
        }
        await wait(speed / 4);
      }
      await wait(speed / 2);
      
      linkedList.push(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.push(new Animated.Value(0));
      barColors.current.push(new Animated.Value(2));
      
      const lastIndex = linkedList.length - 1;
      if (barColors.current[lastIndex]) {
        barColors.current[lastIndex].setValue(2); // Yeni tail'i vurgula
      }
      setExplanationText(`âœ… ${value} sona eklendi! Son dÃ¼ÄŸÃ¼mÃ¼n next'i gÃ¼ncellendi. Zaman: O(n)`);
      addLogMessage(`Sona ekleme tamamlandÄ±: ${value} eklendi`);
    }
    await wait(speed);
  };
  
  const demoSearch = async (linkedList: number[]) => {
    if (linkedList.length > 0) {
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      const searchValue = linkedList[Math.floor(linkedList.length / 2)];
      setExplanationText(`ğŸ” DoÄŸrusal Arama: ${searchValue} deÄŸeri HEAD'den baÅŸlayarak aranÄ±yor...`);
      addLogMessage(`Arama demo: ${searchValue} aranÄ±yor`);
      
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        }
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor: ${linkedList[i]} === ${searchValue}?`);
        addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} kontrol ediliyor: ${linkedList[i]} == ${searchValue}?`);
        await wait(speed / 3);
        
        if (linkedList[i] === searchValue) {
          if (barColors.current[i]) {
            barColors.current[i].setValue(3); // SÄ±ralanmÄ±ÅŸ rengi
          }
          setExplanationText(`ğŸ‰ ${searchValue} bulundu! ${i + 1} adÄ±mda. Average: O(n/2), Worst: O(n)`);
          addLogMessage(`BULUNDU! ${searchValue} deÄŸeri ${i+1}. pozisyonda`);
          await wait(speed);
          break;
        }
      }
    }
  };
  
  const demoTraverse = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    if (barColors.current) {
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
    }
    
    setExplanationText('ğŸš¶â€â™‚ï¸ Liste DolaÅŸma: HEAD\'den baÅŸlayarak her dÃ¼ÄŸÃ¼m next pointer ile ziyaret ediliyor...');
    addLogMessage('Liste dolaÅŸma demo baÅŸlatÄ±ldÄ±');
    
    for (let i = 0; i < linkedList.length; i++) {
      if (barColors.current && barColors.current[i]) {
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (ziyaret)
      }
      setExplanationText(`ğŸš¶â€â™‚ï¸ ${i + 1}. dÃ¼ÄŸÃ¼m ziyaret edildi: ${linkedList[i]} â†’ next`);
      addLogMessage(`DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${linkedList[i]}`);
      await wait(speed / 3);
    }
    
    // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
    if (barColors.current) {
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(3);
      });
    }
    setExplanationText('âœ… Traverse tamamlandÄ±! TÃ¼m dÃ¼ÄŸÃ¼mler tek tek ziyaret edildi. Zaman: O(n)');
    addLogMessage('Liste dolaÅŸma tamamlandÄ±');
    await wait(speed / 2);
  };
  
  const demoDelete = async (linkedList: number[], position: 'head' | 'tail') => {
    if (linkedList.length === 0) return;
    
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    if (position === 'head') {
      const value = linkedList[0];
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Takas rengi
      }
      setExplanationText(`ğŸ—‘ï¸ BaÅŸtan Silme: HEAD dÃ¼ÄŸÃ¼mÃ¼ (${value}) siliniyor...`);
      addLogMessage(`BaÅŸtan silme demo: ${value} siliniyor`);
      await wait(speed);
      
      setExplanationText(`ğŸ”— HEAD pointer ikinci dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek ÅŸekilde gÃ¼ncelleniyor...`);
      if (linkedList.length > 1 && barColors.current[1]) {
        barColors.current[1].setValue(1); // Ä°kinci dÃ¼ÄŸÃ¼mÃ¼ vurgula
      }
      await wait(speed / 2);
      
      linkedList.shift();
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.shift();
      barColors.current.shift();
      setArray([...linkedList]);
      setExplanationText(`âœ… ${value} silindi! HEAD gÃ¼ncellendi. Zaman: O(1)`);
      addLogMessage(`BaÅŸtan silme tamamlandÄ±: ${value} silindi`);
    } else {
      const value = linkedList[linkedList.length - 1];
      setExplanationText(`ğŸ—‘ï¸ Sondan Silme: Son dÃ¼ÄŸÃ¼m (${value}) iÃ§in Ã¶nceki dÃ¼ÄŸÃ¼m aranÄ±yor...`);
      addLogMessage(`Sondan silme demo: ${value} siliniyor`);
      
      // Son dÃ¼ÄŸÃ¼mden Ã¶nceki dÃ¼ÄŸÃ¼me git
      for (let i = 0; i < linkedList.length - 1; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        }
        await wait(speed / 4);
      }
      await wait(speed / 2);
      
      const lastIndex = linkedList.length - 1;
      if (barColors.current[lastIndex]) {
        barColors.current[lastIndex].setValue(2); // Takas rengi
      }
      setExplanationText(`ğŸ”— Ã–nceki dÃ¼ÄŸÃ¼mÃ¼n next'i NULL olarak ayarlanÄ±yor...`);
      addLogMessage(`Son dÃ¼ÄŸÃ¼m bulundu: BaÄŸlantÄ± koparÄ±lÄ±yor`);
      await wait(speed);
      
      linkedList.pop();
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.pop();
      barColors.current.pop();
      setArray([...linkedList]);
      setExplanationText(`âœ… ${value} silindi! Son dÃ¼ÄŸÃ¼mÃ¼n baÄŸlantÄ±sÄ± kesildi. Zaman: O(n)`);
      addLogMessage(`Sondan silme tamamlandÄ±: ${value} silindi`);
    }
    await wait(speed / 2);
  };
  
  const showMemoryManagement = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    setExplanationText('ğŸ’¾ Bellek YÃ¶netimi: DÃ¼ÄŸÃ¼mler bellekte rastgele yerlerde saklanÄ±r, pointer\'lar onlarÄ± birbirine baÄŸlar.');
    addLogMessage('Bellek yÃ¶netimi aÃ§Ä±klanÄ±yor');
    await wait(speed);
    
    if (linkedList.length > 0) {
      // TÃ¼m dÃ¼ÄŸÃ¼mleri farklÄ± bir renk yap
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(1);
      });
      setExplanationText(`ğŸ“Š Bellek KullanÄ±mÄ±: ${linkedList.length} dÃ¼ÄŸÃ¼m Ã— (veri + pointer) = Dinamik boyut`);
      addLogMessage(`Bellek kullanÄ±mÄ±: ${linkedList.length} dÃ¼ÄŸÃ¼m Ã— (veri + pointer)`);
      await wait(speed);
    }
  };
  
  const demoComplete = async (linkedList: number[]) => {
    // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(3);
    });
    
    const summary = linkedList.length > 0 ? 
      `[HEADâ†’${linkedList.join('â†’')}â†’NULL]` : 
      '[HEADâ†’NULL (BoÅŸ Liste)]';
      
    setExplanationText(`âœ… BaÄŸlÄ± Liste Demo tamamlandÄ±! Final durum: ${summary} (${linkedList.length} dÃ¼ÄŸÃ¼m)`);
    addLogMessage(`Demo tamamlandÄ±: ${summary}`);
    await wait(speed);
  };
  
  // Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste gÃ¶rselleÅŸtirmesi
  const visualizeDoublyLinkedList = async () => {
    if (sorting) return;
    
    // Operasyon tipine gÃ¶re uygun fonksiyonu Ã§aÄŸÄ±r
    switch (selectedOperation) {
      case 'demo':
        await performDoublyLinkedListDemo();
        break;
      case 'prepend':
        await performDoublyPrepend();
        break;
      case 'append':
        await performDoublyAppend();
        break;
      case 'insert':
        // Pozisyona ekleme iÅŸlemini performInsertAt fonksiyonunu kullanarak yap
        await performInsertAt();
        break;
      case 'search':
        // Arama iÅŸlemini performSearch fonksiyonunu kullanarak yap
        await performSearch();
        break;
      case 'deleteHead':
        // BaÅŸtan silme iÅŸlemini performDeleteHead fonksiyonunu kullanarak yap
        await performDeleteHead();
        break;
      case 'deleteTail':
        // Sondan silme iÅŸlemini performDeleteTail fonksiyonunu kullanarak yap
        await performDeleteTail();
        break;
      case 'deleteValue':
        // DeÄŸer silme iÅŸlemini performDeleteValue fonksiyonunu kullanarak yap
        await performDeleteValue();
        break;
      case 'traverse':
        await performDoublyTraverse();
        break;
      case 'traverseBackward':
        await performDoublyTraverseBackward();
        break;
      case 'clear':
        // Liste temizleme iÅŸlemini performClear fonksiyonunu kullanarak yap
        await performDoublyClear();
        break;
      default:
        setExplanationText('LÃ¼tfen bir iÅŸlem seÃ§in.');
    }
  };
  
  // Demo - Ã‡ift yÃ¶nlÃ¼ baÄŸlÄ± liste operasyonlarÄ±
  const performDoublyLinkedListDemo = async () => {
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(12);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      let linkedList = [...array];
      setExplanationText('ğŸ”—â†”ï¸ Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo: Ä°leri ve geri yÃ¶nde baÄŸlantÄ±larÄ± keÅŸfedelim...');
      addLogMessage('Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo baÅŸlatÄ±ldÄ±');
      await wait(speed);
      
      // Ã‡ift yÃ¶nlÃ¼ baÄŸlÄ± liste spesifik demo adÄ±mlarÄ± - bu adÄ±mlara null kontrolÃ¼ ekleyeceÄŸiz
      const doublyOperations = [
        { name: 'YapÄ± AÃ§Ä±klamasÄ±', action: async () => { try { await explainStructure(linkedList); } catch (e) { console.error(e); } } },
        { name: 'HEAD & TAIL Pointers', action: async () => { try { await showHeadPointer(linkedList); } catch (e) { console.error(e); } } },
        { name: 'BaÅŸa Ekleme O(1)', action: async () => { try { await doublyDemoInsert(linkedList, 'head'); } catch (e) { console.error(e); } } },
        { name: 'Sona Ekleme O(1)', action: async () => { try { await doublyDemoInsert(linkedList, 'tail'); } catch (e) { console.error(e); } } },
        { name: 'Ã‡ift YÃ¶nlÃ¼ Arama', action: async () => { try { await doublyDemoSearch(linkedList); } catch (e) { console.error(e); } } },
        { name: 'Ä°leri DolaÅŸma', action: async () => { try { await doublyDemoTraverse(linkedList, 'forward'); } catch (e) { console.error(e); } } },
        { name: 'Geri DolaÅŸma', action: async () => { try { await doublyDemoTraverse(linkedList, 'backward'); } catch (e) { console.error(e); } } },
        { name: 'BaÅŸtan Silme O(1)', action: async () => { try { await doublyDemoDelete(linkedList, 'head'); } catch (e) { console.error(e); } } },
        { name: 'Sondan Silme O(1)', action: async () => { try { await doublyDemoDelete(linkedList, 'tail'); } catch (e) { console.error(e); } } },
        { name: 'Bidirectional Links', action: async () => { try { await showBidirectionalLinks(linkedList); } catch (e) { console.error(e); } } },
        { name: 'Bellek AvantajlarÄ±', action: async () => { try { await showDoublyMemoryAdvantages(linkedList); } catch (e) { console.error(e); } } },
        { name: 'Demo TamamlandÄ±', action: async () => { try { await doublyDemoComplete(linkedList); } catch (e) { console.error(e); } } }
      ];
      
      for (let i = 0; i < doublyOperations.length; i++) {
        setCurrentStep(i + 1);
        addLogMessage(`Demo adÄ±m ${i+1}: ${doublyOperations[i].name}`);
        await doublyOperations[i].action();
        linkedList = [...array]; // GÃ¼ncel listeyi al
      }
      
    } catch (error) {
      console.error("Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo sÄ±rasÄ±nda hata:", error);
      setExplanationText("Demo sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Ã‡ift yÃ¶nlÃ¼ liste demo iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Ã‡ift yÃ¶nlÃ¼ baÅŸa ekleme
  const performDoublyPrepend = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen eklenecek deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(4);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      let linkedList = [...array];
      
      setCurrentStep(1);
      setExplanationText(`â• Ã‡ift yÃ¶nlÃ¼ baÅŸa ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Ã‡ift yÃ¶nlÃ¼ baÅŸa ekleme iÅŸlemi: ${value}`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      setCurrentStep(2);
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i mevcut HEAD'i gÃ¶sterecek...`);
      addLogMessage(`Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i HEAD'i gÃ¶sterecek`);
      if (linkedList.length > 0) {
        barColors.current[0].setValue(1); // Mevcut head'i vurgula
      }
      await wait(speed);
      
      setCurrentStep(3);
      setExplanationText(`ğŸ”—â†”ï¸ Mevcut HEAD'in previous'Ä± yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek...`);
      addLogMessage(`HEAD'in previous'Ä± yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek (Ã§ift yÃ¶nlÃ¼ baÄŸlantÄ±)`);
      await wait(speed);
      
      setCurrentStep(4);
      linkedList.unshift(value);
      setArray([...linkedList]);
      barColors.current[0].setValue(2); // Yeni head'i vurgula
      setExplanationText(`âœ… ${value} baÅŸa eklendi! HEAD gÃ¼ncellendi, Ã§ift yÃ¶nlÃ¼ baÄŸlantÄ±lar kuruldu. Zaman: O(1)`);
      addLogMessage(`BaÅŸa ekleme tamamlandÄ±: ${value} deÄŸeri eklendi`);
      setInputValue('');
      
    } catch (error) {
      console.error("Doubly Prepend sÄ±rasÄ±nda hata:", error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Ã‡ift yÃ¶nlÃ¼ baÅŸa ekleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Ã‡ift yÃ¶nlÃ¼ sona ekleme
  const performDoublyAppend = async () => {
    if (!inputValue.trim()) {
      setExplanationText('âš ï¸ LÃ¼tfen eklenecek deÄŸeri girin!');
      return;
    }
    
    const value = parseInt(inputValue);
    if (isNaN(value)) {
      setExplanationText('âš ï¸ LÃ¼tfen geÃ§erli bir sayÄ± girin!');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(4);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      let linkedList = [...array];
      
      setCurrentStep(1);
      setExplanationText(`â• Ã‡ift yÃ¶nlÃ¼ sona ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Ã‡ift yÃ¶nlÃ¼ sona ekleme iÅŸlemi: ${value}`);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      setCurrentStep(2);
      setExplanationText(`ğŸ”— TAIL pointer sayesinde son dÃ¼ÄŸÃ¼me direkt eriÅŸim! O(1)`);
      addLogMessage(`TAIL pointer kullanÄ±larak son dÃ¼ÄŸÃ¼me eriÅŸiliyor`);
      if (linkedList.length > 0) {
        barColors.current[linkedList.length - 1].setValue(1); // Mevcut tail'i vurgula
      }
      await wait(speed);
      
      setCurrentStep(3);
      setExplanationText(`ğŸ”—â†”ï¸ Ã‡ift yÃ¶nlÃ¼ baÄŸlantÄ±lar kuruluyor: previous â† â†’ next`);
      addLogMessage(`Ã‡ift yÃ¶nlÃ¼ baÄŸlantÄ±lar kuruluyor: previous ve next`);
      await wait(speed);
      
      setCurrentStep(4);
      linkedList.push(value);
      setArray([...linkedList]);
      barColors.current[linkedList.length - 1].setValue(2); // Yeni tail'i vurgula
      setExplanationText(`âœ… ${value} sona eklendi! TAIL gÃ¼ncellendi, Ã§ift yÃ¶nlÃ¼ baÄŸlantÄ±lar kuruldu. Zaman: O(1)`);
      addLogMessage(`Sona ekleme tamamlandÄ±: ${value} deÄŸeri eklendi`);
      setInputValue('');
      
    } catch (error) {
      console.error("Doubly Append sÄ±rasÄ±nda hata:", error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Ã‡ift yÃ¶nlÃ¼ sona ekleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Ã‡ift yÃ¶nlÃ¼ ileri traverse
  const performDoublyTraverse = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste boÅŸ! DolaÅŸÄ±lacak eleman yok.');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(array.length);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      setExplanationText('ğŸš¶â€â™‚ï¸â¡ï¸ Ä°leri DolaÅŸma: HEAD\'den TAIL\'e doÄŸru next pointer\'larÄ± takip ediliyor...');
      addLogMessage('Ä°leri dolaÅŸma iÅŸlemi baÅŸlatÄ±ldÄ±: HEADâ†’TAIL');
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      await wait(speed);
      
      for (let i = 0; i < array.length; i++) {
        setCurrentStep(i + 1);
        barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (ziyaret)
        setExplanationText(`â¡ï¸ ${i + 1}. dÃ¼ÄŸÃ¼m ziyaret edildi: ${array[i]} (nextâ†’)`);
        addLogMessage(`Ä°leri dolaÅŸma: DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${array[i]}`);
        await wait(speed);
      }
      
      // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
      barColors.current.forEach(color => color.setValue(3));
      setExplanationText(`âœ… Ä°leri dolaÅŸma tamamlandÄ±! ${array.length} dÃ¼ÄŸÃ¼m HEADâ†’TAIL yÃ¶nÃ¼nde ziyaret edildi.`);
      addLogMessage(`Ä°leri dolaÅŸma tamamlandÄ±: ${array.length} dÃ¼ÄŸÃ¼m ziyaret edildi`);
      
    } catch (error) {
      console.error("Doubly Traverse sÄ±rasÄ±nda hata:", error);
      setExplanationText("DolaÅŸma sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Ä°leri dolaÅŸma iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Ã‡ift yÃ¶nlÃ¼ geri traverse
  const performDoublyTraverseBackward = async () => {
    if (array.length === 0) {
      setExplanationText('âš ï¸ Liste boÅŸ! DolaÅŸÄ±lacak eleman yok.');
      return;
    }
    
    try {
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(array.length);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      setExplanationText('ğŸš¶â€â™‚ï¸â¬…ï¸ Geri DolaÅŸma: TAIL\'den HEAD\'e doÄŸru previous pointer\'larÄ± takip ediliyor...');
      addLogMessage('Geri dolaÅŸma iÅŸlemi baÅŸlatÄ±ldÄ±: TAILâ†HEAD');
      
      // BarlarÄ± normal renge dÃ¶ndÃ¼r - null kontrolÃ¼ ile
      if (barColors.current) {
        barColors.current.forEach((color, index) => {
          if (color) color.setValue(0);
        });
      }
      
      await wait(speed);
      
      for (let i = array.length - 1; i >= 0; i--) {
        setCurrentStep(array.length - i);
        if (barColors.current && barColors.current[i]) {
          barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (ziyaret)
        }
        setExplanationText(`â¬…ï¸ ${array.length - i}. adÄ±m: ${array[i]} (â†previous)`);
        addLogMessage(`Geri dolaÅŸma: DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${array[i]}`);
        await wait(speed);
      }
      
      // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
      if (barColors.current) {
        barColors.current.forEach((color, index) => {
          if (color) color.setValue(3);
        });
      }
      
      setExplanationText(`âœ… Geri dolaÅŸma tamamlandÄ±! ${array.length} dÃ¼ÄŸÃ¼m TAILâ†HEAD yÃ¶nÃ¼nde ziyaret edildi.`);
      addLogMessage(`Geri dolaÅŸma tamamlandÄ±: ${array.length} dÃ¼ÄŸÃ¼m ziyaret edildi`);
      
    } catch (error) {
      console.error("Doubly Traverse Backward sÄ±rasÄ±nda hata:", error);
      setExplanationText("Geri dolaÅŸma sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Geri dolaÅŸma iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  const doublyDemoInsert = async (linkedList: number[], position: 'head' | 'tail') => {
    const value = Math.floor(Math.random() * 100) + 1;
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    if (position === 'head') {
      setExplanationText(`â• BaÅŸa Ekleme: Yeni dÃ¼ÄŸÃ¼m (${value}) oluÅŸturuluyor...`);
      addLogMessage(`BaÅŸa ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i mevcut HEAD'i gÃ¶sterecek...`);
      if (linkedList.length > 0 && barColors.current[0]) {
        barColors.current[0].setValue(1); // Head'i vurgula
      }
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”—â†”ï¸ Mevcut HEAD'in previous'Ä± yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek...`);
      await wait(speed / 2);
      
      linkedList.unshift(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current = [new Animated.Value(0), ...barRefs.current];
      barColors.current = [new Animated.Value(2), ...barColors.current];
      
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Yeni head'i vurgula
      }
      setExplanationText(`âœ… ${value} baÅŸa eklendi! Zaman: O(1)`);
      addLogMessage(`BaÅŸa ekleme tamamlandÄ±: ${value} eklendi`);
    } else {
      setExplanationText(`â• Sona Ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Sona ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”— TAIL sayesinde son dÃ¼ÄŸÃ¼me direkt eriÅŸim! O(1)`);
      if (linkedList.length > 0 && barColors.current[linkedList.length - 1]) {
        barColors.current[linkedList.length - 1].setValue(1); // Tail'i vurgula
      }
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”—â†”ï¸ Ã‡ift yÃ¶nlÃ¼ baÄŸlantÄ±lar kuruluyor...`);
      await wait(speed / 2);
      
      linkedList.push(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.push(new Animated.Value(0));
      barColors.current.push(new Animated.Value(2));
      
      const lastIndex = linkedList.length - 1;
      if (barColors.current[lastIndex]) {
        barColors.current[lastIndex].setValue(2); // Yeni tail'i vurgula
      }
      setExplanationText(`âœ… ${value} sona eklendi! Zaman: O(1)`);
      addLogMessage(`Sona ekleme tamamlandÄ±: ${value} eklendi`);
    }
    await wait(speed);
  };
  
  const doublyDemoSearch = async (linkedList: number[]) => {
    if (linkedList.length === 0) return;
    
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    const searchValue = linkedList[Math.floor(linkedList.length / 2)];
    setExplanationText(`ğŸ” Optimized Search: ${searchValue} deÄŸeri iki uÃ§tan baÅŸlayarak aranÄ±yor...`);
    addLogMessage(`Ã‡ift yÃ¶nlÃ¼ arama demo: ${searchValue} aranÄ±yor`);
    
    let left = 0;
    let right = linkedList.length - 1;
    let found = false;
    
    while (left <= right && !found) {
      // Sol taraftan ara
      if (barColors.current[left]) {
        barColors.current[left].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
      }
      setExplanationText(`ğŸ” HEAD tarafÄ±ndan ${left + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor: ${linkedList[left]} === ${searchValue}?`);
      addLogMessage(`HEAD tarafÄ±ndan kontrol: ${linkedList[left]} == ${searchValue}?`);
      await wait(speed / 3);
      
      if (linkedList[left] === searchValue) {
        if (barColors.current[left]) {
          barColors.current[left].setValue(3); // SÄ±ralanmÄ±ÅŸ rengi
        }
        setExplanationText(`ğŸ‰ ${searchValue} bulundu! HEAD tarafÄ±ndan ${left + 1} adÄ±mda. O(n/2)`);
        addLogMessage(`BULUNDU! ${searchValue} deÄŸeri ${left+1}. pozisyonda (HEAD tarafÄ±ndan)`);
        found = true;
        break;
      }
      
      if (left !== right) {
        // SaÄŸ taraftan ara
        if (barColors.current[right]) {
          barColors.current[right].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi
        }
        setExplanationText(`ğŸ” TAIL tarafÄ±ndan ${right + 1}. dÃ¼ÄŸÃ¼m kontrol ediliyor: ${linkedList[right]} === ${searchValue}?`);
        addLogMessage(`TAIL tarafÄ±ndan kontrol: ${linkedList[right]} == ${searchValue}?`);
        await wait(speed / 3);
        
        if (linkedList[right] === searchValue) {
          if (barColors.current[right]) {
            barColors.current[right].setValue(3); // SÄ±ralanmÄ±ÅŸ rengi
          }
          setExplanationText(`ğŸ‰ ${searchValue} bulundu! TAIL tarafÄ±ndan ${linkedList.length - right} adÄ±mda. O(n/2)`);
          addLogMessage(`BULUNDU! ${searchValue} deÄŸeri ${right+1}. pozisyonda (TAIL tarafÄ±ndan)`);
          found = true;
          break;
        }
      }
      
      // Elemanlar bulunamadÄ±, bir sonraki adÄ±ma geÃ§
      if (barColors.current[left]) barColors.current[left].setValue(0);
      if (left !== right && barColors.current[right]) barColors.current[right].setValue(0);
      
      left++;
      right--;
    }
    
    if (!found) {
      setExplanationText(`âŒ ${searchValue} deÄŸeri listede bulunamadÄ±!`);
      addLogMessage(`Arama tamamlandÄ±: ${searchValue} deÄŸeri bulunamadÄ±`);
    }
    
    await wait(speed);
  };
  
  const doublyDemoTraverse = async (linkedList: number[], direction: 'forward' | 'backward') => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    if (barColors.current) {
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
    }
    
    if (direction === 'forward') {
      setExplanationText('ğŸš¶â€â™‚ï¸â¡ï¸ Ä°leri DolaÅŸma: HEAD\'den TAIL\'e doÄŸru next pointer\'larÄ± takip ediliyor...');
      addLogMessage('Ä°leri dolaÅŸma demo baÅŸlatÄ±ldÄ±');
      
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current && barColors.current[i]) {
          barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (ziyaret)
        }
        setExplanationText(`â¡ï¸ ${i + 1}. dÃ¼ÄŸÃ¼m ziyaret edildi: ${linkedList[i]} â†’ next`);
        addLogMessage(`Ä°leri dolaÅŸma: DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${linkedList[i]}`);
        await wait(speed / 3);
      }
    } else {
      setExplanationText('ğŸš¶â€â™‚ï¸â¬…ï¸ Geri DolaÅŸma: TAIL\'den HEAD\'e doÄŸru previous pointer\'larÄ± takip ediliyor...');
      addLogMessage('Geri dolaÅŸma demo baÅŸlatÄ±ldÄ±');
      
      for (let i = linkedList.length - 1; i >= 0; i--) {
        if (barColors.current && barColors.current[i]) {
          barColors.current[i].setValue(1); // KarÅŸÄ±laÅŸtÄ±rma rengi (ziyaret)
        }
        setExplanationText(`â¬…ï¸ ${linkedList.length - i}. adÄ±m: ${linkedList[i]} â† previous`);
        addLogMessage(`Geri dolaÅŸma: DÃ¼ÄŸÃ¼m ${i+1} ziyaret edildi: ${linkedList[i]}`);
        await wait(speed / 3);
      }
    }
    
    // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
    if (barColors.current) {
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(3);
      });
    }
    setExplanationText(`âœ… ${direction === 'forward' ? 'Ä°leri' : 'Geri'} dolaÅŸma tamamlandÄ±! O(n)`);
    addLogMessage(`${direction === 'forward' ? 'Ä°leri' : 'Geri'} dolaÅŸma tamamlandÄ±`);
    await wait(speed / 2);
  };
  
  const doublyDemoDelete = async (linkedList: number[], position: 'head' | 'tail') => {
    if (linkedList.length === 0) return;
    
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    if (position === 'head') {
      const value = linkedList[0];
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Takas rengi
      }
      setExplanationText(`ğŸ—‘ï¸ BaÅŸtan Silme: HEAD dÃ¼ÄŸÃ¼mÃ¼ (${value}) siliniyor...`);
      addLogMessage(`BaÅŸtan silme demo: ${value} siliniyor`);
      await wait(speed);
      
      setExplanationText(`ğŸ”— HEAD pointer ikinci dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek...`);
      if (linkedList.length > 1 && barColors.current[1]) {
        barColors.current[1].setValue(1); // Ä°kinci dÃ¼ÄŸÃ¼mÃ¼ vurgula
      }
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”—â†”ï¸ Yeni HEAD'in previous'Ä± NULL yapÄ±lÄ±yor...`);
      await wait(speed / 2);
      
      linkedList.shift();
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.shift();
      barColors.current.shift();
      setArray([...linkedList]);
      setExplanationText(`âœ… ${value} silindi! Zaman: O(1)`);
      addLogMessage(`BaÅŸtan silme tamamlandÄ±: ${value} silindi`);
    } else {
      const value = linkedList[linkedList.length - 1];
      const lastIndex = linkedList.length - 1;
      if (barColors.current[lastIndex]) {
        barColors.current[lastIndex].setValue(2); // Takas rengi
      }
      setExplanationText(`ğŸ—‘ï¸ Sondan Silme: TAIL dÃ¼ÄŸÃ¼mÃ¼ (${value}) siliniyor...`);
      addLogMessage(`Sondan silme demo: ${value} siliniyor`);
      await wait(speed);
      
      setExplanationText(`ğŸ”— TAIL pointer Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek...`);
      if (linkedList.length > 1 && barColors.current[lastIndex - 1]) {
        barColors.current[lastIndex - 1].setValue(1); // Ã–nceki dÃ¼ÄŸÃ¼mÃ¼ vurgula
      }
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”—â†”ï¸ Yeni TAIL'in next'i NULL yapÄ±lÄ±yor...`);
      await wait(speed / 2);
      
      linkedList.pop();
      // Animasyon deÄŸerlerini gÃ¼ncelle
      barRefs.current.pop();
      barColors.current.pop();
      setArray([...linkedList]);
      setExplanationText(`âœ… ${value} silindi! Zaman: O(1)`);
      addLogMessage(`Sondan silme tamamlandÄ±: ${value} silindi`);
    }
    await wait(speed / 2);
  };
  
  const showBidirectionalLinks = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    setExplanationText('ğŸ”„ Ã‡ift YÃ¶nlÃ¼ BaÄŸlantÄ±lar: DÃ¼ÄŸÃ¼mler arasÄ±nda ileri ve geri yÃ¶nde gezinti saÄŸlar.');
    addLogMessage('Ã‡ift yÃ¶nlÃ¼ baÄŸlantÄ±lar aÃ§Ä±klanÄ±yor');
    await wait(speed);
    
    if (linkedList.length > 1) {
      // Ä°lk dÃ¼ÄŸÃ¼m next baÄŸlantÄ±sÄ±
      if (barColors.current[0]) barColors.current[0].setValue(1);
      if (barColors.current[1]) barColors.current[1].setValue(1);
      setExplanationText(`â¡ï¸ ${linkedList[0]} â†’ ${linkedList[1]} (next pointer)`);
      addLogMessage(`${linkedList[0]} â†’ ${linkedList[1]} (next baÄŸlantÄ±sÄ±)`);
      await wait(speed / 2);
      
      // Ä°kinci dÃ¼ÄŸÃ¼m previous baÄŸlantÄ±sÄ±
      if (barColors.current[0]) barColors.current[0].setValue(1);
      if (barColors.current[1]) barColors.current[1].setValue(1);
      setExplanationText(`â¬…ï¸ ${linkedList[1]} â† ${linkedList[0]} (previous pointer)`);
      addLogMessage(`${linkedList[1]} â† ${linkedList[0]} (previous baÄŸlantÄ±sÄ±)`);
      await wait(speed / 2);
    }
  };
  
  const showDoublyMemoryAdvantages = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    setExplanationText('ğŸ’¾ Ã‡ift YÃ¶nlÃ¼ Liste AvantajlarÄ±: Hem ileriye hem geriye doÄŸru O(1) zamanda hareket.');
    addLogMessage('Ã‡ift yÃ¶nlÃ¼ liste avantajlarÄ± aÃ§Ä±klanÄ±yor');
    await wait(speed);
    
    setExplanationText('âš–ï¸ Trade-off: Daha hÄ±zlÄ± iÅŸlemler vs. her dÃ¼ÄŸÃ¼m iÃ§in bir extra pointer maliyeti');
    addLogMessage('Ã‡ift yÃ¶nlÃ¼ liste dezavantajlarÄ±: Daha fazla bellek kullanÄ±mÄ±');
    await wait(speed);
  };
  
  const doublyDemoComplete = async (linkedList: number[]) => {
    // TÃ¼m barlarÄ± sÄ±ralanmÄ±ÅŸ renk yap (tamamlandÄ±)
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(3);
    });
    
    const summary = linkedList.length > 0 ? 
      `[NULLâ†${linkedList.join('â†”')}â†’NULL]` : 
      '[NULLâ†â†’NULL (BoÅŸ Liste)]';
      
    setExplanationText(`âœ… Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste Demo tamamlandÄ±! Final durum: ${summary}`);
    addLogMessage(`Demo tamamlandÄ±: ${summary}`);
    await wait(speed);
  };
  
  const performDoublyClear = async () => {
    // Mevcut temizleme fonksiyonunu kullan
    try {
      if (array.length === 0) {
        setExplanationText('âš ï¸ Liste zaten boÅŸ!');
        return;
      }
      
      setSorting(true);
      setCurrentStep(0);
      setTotalSteps(1);
      setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
      
      setCurrentStep(1);
      setExplanationText('ğŸ—‘ï¸ TÃ¼m liste temizleniyor...');
      addLogMessage('Liste temizleme iÅŸlemi baÅŸlatÄ±ldÄ±');
      
      // TÃ¼m barlarÄ± takas rengi yap (siliniyor)
      if (barColors.current) {
        barColors.current.forEach((color, index) => {
          if (color) color.setValue(2);
        });
      }
      
      await wait(speed);
      
      setArray([]);
      // Animasyon dizilerini de sÄ±fÄ±rla
      barRefs.current = [];
      barColors.current = [];
      
      setExplanationText('âœ… Liste tamamen temizlendi! HEAD ve TAIL pointer\'larÄ± NULL olarak ayarlandÄ±.');
      addLogMessage('Liste temizleme tamamlandÄ±: TÃ¼m dÃ¼ÄŸÃ¼mler silindi');
    } catch (error) {
      console.error("Clear sÄ±rasÄ±nda hata:", error);
      setExplanationText("Temizleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
      addLogMessage("HATA: Liste temizleme iÅŸlemi baÅŸarÄ±sÄ±z oldu");
    } finally {
      setSorting(false);
    }
  };
  
  // Merge Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeMergeSort = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    
    const arr = [...array];
    const n = arr.length;
    
    // YardÄ±mcÄ± array oluÅŸtur (Merge Sort ek bellek kullanÄ±r)
    const auxiliaryArray = [...arr];
    
    setExplanationText('Merge Sort: Dizi, kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lÃ¼nÃ¼p sonra birleÅŸtirilecek. Bu algoritma bÃ¶l-ve-yÃ¶net prensibiyle Ã§alÄ±ÅŸÄ±r.');
    
    // Algoritma adÄ±mlarÄ±nÄ± aÃ§Ä±klayan array
    const steps = [
      '1. Diziyi ortadan ikiye bÃ¶l',
      '2. Sol yarÄ±yÄ± Ã¶zyinelemeli olarak sÄ±rala',
      '3. SaÄŸ yarÄ±yÄ± Ã¶zyinelemeli olarak sÄ±rala',
      '4. Ä°ki sÄ±ralÄ± yarÄ±yÄ± birleÅŸtir',
      '5. KarÅŸÄ±laÅŸtÄ±rma ve birleÅŸtirme iÅŸlemi sÄ±rasÄ±nda, her iki yarÄ±dan elemanlarÄ± karÅŸÄ±laÅŸtÄ±r ve daha kÃ¼Ã§Ã¼k olanÄ± yeni diziye yerleÅŸtir'
    ];
    
    // AdÄ±mlarÄ± gÃ¶ster
    addLogMessage('--- Merge Sort AdÄ±mlarÄ± ---');
    steps.forEach(step => addLogMessage(step));
    addLogMessage('------------------------');
    
    // Log2(n) * n civarÄ±nda adÄ±m olacak (bÃ¶l ve birleÅŸtir)
    const totalSteps = Math.ceil(n * Math.log2(n));
    setTotalSteps(totalSteps);
    
    let stepCount = 0;
    
    try {
      await mergeSortHelper(arr, auxiliaryArray, 0, n - 1, stepCount);
      
      // TÃ¼m elemanlarÄ± sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      for (let i = 0; i < n; i++) {
        await animateColor(i, 3);
      }
      
      setExplanationText('Merge Sort tamamlandÄ±! KarmaÅŸÄ±klÄ±k: En iyi, Ortalama ve En kÃ¶tÃ¼ durumda: O(n log n), Bellek KullanÄ±mÄ±: O(n)');
      addLogMessage('Merge Sort tamamlandÄ±! Bu algoritma kararlÄ± (stable) bir sÄ±ralama algoritmasÄ±dÄ±r.');
    } catch (error) {
      console.error("Merge Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Merge Sort yardÄ±mcÄ± fonksiyonu (recursive)
  const mergeSortHelper = async (mainArray: number[], auxiliaryArray: number[], 
                                left: number, right: number, stepCount: number): Promise<number> => {
    if (left === right) return stepCount;
    
    const middle = Math.floor((left + right) / 2);
    
    // BÃ¶lme adÄ±mÄ± - sol yarÄ±yÄ± sÄ±rala
    stepCount = await mergeSortHelper(mainArray, auxiliaryArray, left, middle, stepCount);
    
    // BÃ¶lme adÄ±mÄ± - saÄŸ yarÄ±yÄ± sÄ±rala
    stepCount = await mergeSortHelper(mainArray, auxiliaryArray, middle + 1, right, stepCount);
    
    // BirleÅŸtirme adÄ±mÄ±
    stepCount = await doMerge(mainArray, auxiliaryArray, left, middle, right, stepCount);
    
    return stepCount;
  };
  
  // Ä°ki sÄ±ralÄ± alt diziyi birleÅŸtir
  const doMerge = async (mainArray: number[], auxiliaryArray: number[], 
                         start: number, middle: number, end: number, stepCount: number): Promise<number> => {
    
    setExplanationText(`[${start}...${middle}] ve [${middle+1}...${end}] alt dizileri birleÅŸtiriliyor...`);
    addLogMessage(`BirleÅŸtirme: [${start}...${middle}] ve [${middle+1}...${end}] aralÄ±klarÄ±`);
    
    // Mevcut bÃ¶lgeyi kopyala
    for (let i = start; i <= end; i++) {
      auxiliaryArray[i] = mainArray[i];
      stepCount++;
      setCurrentStep(stepCount);
      await animateColor(i, 1, speed / 2); // Ä°ÅŸlenen alt dizileri vurgula
    }
    
    let i = start;     // Sol alt dizinin baÅŸlangÄ±Ã§ indeksi
    let j = middle + 1; // SaÄŸ alt dizinin baÅŸlangÄ±Ã§ indeksi
    let k = start;     // Ana dizideki mevcut pozisyon
    
    // Ä°ki alt diziyi karÅŸÄ±laÅŸtÄ±rarak birleÅŸtir
    while (i <= middle && j <= end) {
      // Ä°ki elemanÄ± karÅŸÄ±laÅŸtÄ±r, kÃ¼Ã§Ã¼k olanÄ± seÃ§
      if (auxiliaryArray[i] <= auxiliaryArray[j]) {
        mainArray[k] = auxiliaryArray[i];
        
        stepCount++;
        setCurrentStep(stepCount);
        
        // DeÄŸiÅŸtiÄŸini vurgula
        await animateColor(k, 2, speed / 2);
        setArray([...mainArray]);
        
        i++;
      } else {
        mainArray[k] = auxiliaryArray[j];
        
        stepCount++;
        setCurrentStep(stepCount);
        
        // DeÄŸiÅŸtiÄŸini vurgula
        await animateColor(k, 2, speed / 2);
        setArray([...mainArray]);
        
        j++;
      }
      k++;
    }
    
    // Kalan elemanlarÄ± kopyala (sol alt dizi)
    while (i <= middle) {
      mainArray[k] = auxiliaryArray[i];
      
      stepCount++;
      setCurrentStep(stepCount);
      
      // DeÄŸiÅŸtiÄŸini vurgula
      await animateColor(k, 2, speed / 2);
      setArray([...mainArray]);
      
      i++;
      k++;
    }
    
    // Kalan elemanlarÄ± kopyala (saÄŸ alt dizi)
    while (j <= end) {
      mainArray[k] = auxiliaryArray[j];
      
      stepCount++;
      setCurrentStep(stepCount);
      
      // DeÄŸiÅŸtiÄŸini vurgula
      await animateColor(k, 2, speed / 2);
      setArray([...mainArray]);
      
      j++;
      k++;
    }
    
    // BirleÅŸtirilen bÃ¶lgeyi vurgula
    for (let i = start; i <= end; i++) {
      await animateColor(i, 0, speed / 4);
    }
    
    return stepCount;
  };
  
  // Quick Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeQuickSort = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    
    const arr = [...array];
    const n = arr.length;
    
    setExplanationText('Quick Sort: Pivot etrafÄ±nda parÃ§alara ayÄ±rÄ±p sÄ±ralama yapÄ±lacak. BÃ¶l-ve-yÃ¶net stratejisine dayanan hÄ±zlÄ± bir algoritmadÄ±r.');
    
    // Algoritma adÄ±mlarÄ±nÄ± aÃ§Ä±klayan array
    const steps = [
      '1. Diziden bir pivot eleman seÃ§ (genellikle ilk, son veya ortadaki eleman)',
      '2. Diziyi yeniden dÃ¼zenle: Pivottan kÃ¼Ã§Ã¼k elemanlarÄ± sola, bÃ¼yÃ¼k elemanlarÄ± saÄŸa yerleÅŸtir',
      '3. Pivotun solundaki alt diziyi Ã¶zyinelemeli olarak sÄ±rala',
      '4. Pivotun saÄŸÄ±ndaki alt diziyi Ã¶zyinelemeli olarak sÄ±rala',
      '5. Alt dizilerin boyutu 1 veya 0 olduÄŸunda durulur (taban durumu)'
    ];
    
    // AdÄ±mlarÄ± gÃ¶ster
    addLogMessage('--- Quick Sort AdÄ±mlarÄ± ---');
    steps.forEach(step => addLogMessage(step));
    addLogMessage('------------------------');
    
    // YaklaÅŸÄ±k n*log(n) adÄ±m olacak
    const totalSteps = Math.ceil(n * Math.log2(n));
    setTotalSteps(totalSteps);
    
    let stepCount = 0;
    
    try {
      await quickSortHelper(arr, 0, n - 1, stepCount);
      
      // TÃ¼m elemanlarÄ± sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      for (let i = 0; i < n; i++) {
        await animateColor(i, 3);
      }
      
      setExplanationText('Quick Sort tamamlandÄ±! KarmaÅŸÄ±klÄ±k: En iyi ve Ortalama: O(n log n), En kÃ¶tÃ¼: O(nÂ²), Bellek: O(log n)');
      addLogMessage('Quick Sort tamamlandÄ±! Bu algoritma pratik uygulamalarda Ã§ok hÄ±zlÄ± Ã§alÄ±ÅŸan bir sÄ±ralama algoritmasÄ±dÄ±r.');
      addLogMessage('Not: Quick Sort kararlÄ± (stable) bir sÄ±ralama algoritmasÄ± deÄŸildir.');
    } catch (error) {
      console.error("Quick Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Quick Sort yardÄ±mcÄ± fonksiyonu (recursive)
  const quickSortHelper = async (arr: number[], low: number, high: number, stepCount: number): Promise<number> => {
    if (low < high) {
      // Pivot seÃ§imi ve partition
      const pivotIndex = await partition(arr, low, high, stepCount);
      stepCount += (high - low + 1); // Partition iÅŸlemindeki adÄ±m sayÄ±sÄ±
      
      // Pivotun sol tarafÄ±nÄ± sÄ±rala
      stepCount = await quickSortHelper(arr, low, pivotIndex - 1, stepCount);
      
      // Pivotun saÄŸ tarafÄ±nÄ± sÄ±rala
      stepCount = await quickSortHelper(arr, pivotIndex + 1, high, stepCount);
    }
    
    return stepCount;
  };
  
  // Pivot etrafÄ±nda parÃ§alama fonksiyonu
  const partition = async (arr: number[], low: number, high: number, stepCount: number): Promise<number> => {
    // Pivot olarak en saÄŸdaki elemanÄ± seÃ§
    const pivot = arr[high];
    
    setExplanationText(`Pivot: ${pivot}, AralÄ±k: [${low}...${high}]`);
    addLogMessage(`Partition iÅŸlemi: Pivot=${pivot}, AralÄ±k=[${low}...${high}]`);
    await animateColor(high, 1, speed); // Pivotu vurgula
    
    // Pivottan kÃ¼Ã§Ã¼k elemanlarÄ±n son pozisyonu
    let i = low - 1;
    
    // Diziyi tara ve pivottan kÃ¼Ã§Ã¼k olanlarÄ± sol tarafa topla
    for (let j = low; j < high; j++) {
      // Mevcut elemanÄ± pivotla karÅŸÄ±laÅŸtÄ±r
      await animateColor(j, 1, speed / 2);
      setCurrentStep(stepCount + (j - low + 1));
      
      if (arr[j] <= pivot) {
        // Mevcut eleman pivottan kÃ¼Ã§Ã¼k veya eÅŸit, sol tarafa al
        i++;
        
        // i ve j pozisyonlarÄ±ndaki elemanlarÄ± takas et
        if (i !== j) {
          setExplanationText(`${arr[j]} <= ${pivot} olduÄŸu iÃ§in, ${arr[j]} ve ${arr[i]} elemanlarÄ± yer deÄŸiÅŸtiriyor.`);
          addLogMessage(`Yer deÄŸiÅŸtirme: ${arr[j]} <= ${pivot}, ${arr[j]} ve ${arr[i]} elemanlarÄ± takas ediliyor`);
          await animateSwap(i, j);
          [arr[i], arr[j]] = [arr[j], arr[i]];
          setArray([...arr]);
        }
      } else {
        setExplanationText(`${arr[j]} > ${pivot} olduÄŸu iÃ§in, saÄŸ tarafta kalÄ±yor.`);
        addLogMessage(`${arr[j]} > ${pivot} olduÄŸu iÃ§in deÄŸiÅŸiklik yok`);
      }
      
      await animateColor(j, 0, speed / 2);
    }
    
    // Pivotu doÄŸru pozisyona yerleÅŸtir
    if (i + 1 !== high) {
      setExplanationText(`Pivot (${pivot}) doÄŸru pozisyona yerleÅŸtiriliyor.`);
      await animateSwap(i + 1, high);
      [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
      setArray([...arr]);
    }
    
    await animateColor(i + 1, 3, speed); // YerleÅŸtirilmiÅŸ pivotu vurgula
    
    // Pivotun yeni pozisyonunu dÃ¶ndÃ¼r
    return i + 1;
  };
  
  // Bubble Sort algoritmasÄ± iÃ§in gÃ¶rselleÅŸtirme
  const visualizeBubbleSort = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    
    const arr = [...array];
    const n = arr.length;
    
    setExplanationText('KabarcÄ±k SÄ±ralama (Bubble Sort) baÅŸlatÄ±lÄ±yor. En bÃ¼yÃ¼k elemanlar her turda sona doÄŸru kabarcÄ±k gibi yÃ¼kselir.');
    
    // Algoritma adÄ±mlarÄ±nÄ± aÃ§Ä±klayan array
    const steps = [
      '1. Dizinin baÅŸÄ±ndan baÅŸlayarak her bir elemanÄ± bir sonraki eleman ile karÅŸÄ±laÅŸtÄ±r',
      '2. EÄŸer eleman sÄ±ralamaya aykÄ±rÄ± ise yer deÄŸiÅŸtir',
      '3. Dizinin sonuna geldiÄŸinde, baÅŸa dÃ¶n ve aynÄ± sÃ¼reci tekrarla',
      '4. Her bir geÃ§iÅŸte en bÃ¼yÃ¼k eleman dizinin sonuna yerleÅŸir',
      '5. HiÃ§bir deÄŸiÅŸiklik yapÄ±lmayan bir geÃ§iÅŸ gerÃ§ekleÅŸene kadar devam et'
    ];
    
    // AdÄ±mlarÄ± gÃ¶ster
    addLogMessage('--- Bubble Sort AdÄ±mlarÄ± ---');
    steps.forEach(step => addLogMessage(step));
    addLogMessage('------------------------');
    
    // Toplam adÄ±m sayÄ±sÄ±nÄ± belirle (n * n)
    const totalSteps = n * n;
    setTotalSteps(totalSteps);
    
    let stepCount = 0;
    
    try {
      // Bubble sort algoritmasÄ±
      for (let i = 0; i < n - 1; i++) {
        let swapped = false;
        
        // Her turda en bÃ¼yÃ¼k elemanÄ± sona taÅŸÄ±
        setExplanationText(`Tur ${i+1}: En bÃ¼yÃ¼k ${i+1}. eleman sona taÅŸÄ±nacak.`);
        addLogMessage(`Tur ${i+1} baÅŸlÄ±yor: [${arr.join(', ')}]`);
        
        for (let j = 0; j < n - i - 1; j++) {
          stepCount++;
          setCurrentStep(stepCount);
          
          // KarÅŸÄ±laÅŸtÄ±rÄ±lan elemanlarÄ± vurgula
          await animateColor(j, 1, speed / 2); // Ä°lk eleman
          await animateColor(j + 1, 1, speed / 2); // Ä°kinci eleman
          
          // KarÅŸÄ±laÅŸtÄ±rma
          setExplanationText(`KarÅŸÄ±laÅŸtÄ±rma: ${arr[j]} ve ${arr[j+1]}`);
          
          if (arr[j] > arr[j + 1]) {
            // ElemanlarÄ± takas et
            setExplanationText(`${arr[j]} > ${arr[j+1]} olduÄŸu iÃ§in elemanlar yer deÄŸiÅŸtiriyor.`);
            addLogMessage(`Yer deÄŸiÅŸtirme: ${arr[j]} > ${arr[j+1]}, deÄŸiÅŸim yapÄ±lÄ±yor`);
            await animateSwap(j, j + 1);
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            setArray([...arr]);
            swapped = true;
          } else {
            setExplanationText(`${arr[j]} <= ${arr[j+1]} olduÄŸu iÃ§in deÄŸiÅŸiklik yok.`);
          }
          
          // KarÅŸÄ±laÅŸtÄ±rma bitti, normal renge dÃ¶ndÃ¼r
          await animateColor(j, 0, speed / 4);
          
          // Son elemanÄ± daha sÄ±ralanmÄ±ÅŸ olarak iÅŸaretleme
          if (j === n - i - 2) {
            await animateColor(j + 1, 3, speed / 2); // SÄ±ralanmÄ±ÅŸ eleman
          }
        }
        
        // SÄ±ralanmÄ±ÅŸ elemanlarÄ± iÅŸaretle
        for (let k = n - 1; k >= n - i - 1; k--) {
          await animateColor(k, 3, 0); // SÄ±ralanmÄ±ÅŸ bÃ¶lge
        }
        
        addLogMessage(`Tur ${i+1} tamamlandÄ±: [${arr.join(', ')}]`);
        
        // HiÃ§ takas yapÄ±lmadÄ±ysa dizi sÄ±ralanmÄ±ÅŸtÄ±r
        if (!swapped) {
          setExplanationText('HiÃ§ yer deÄŸiÅŸtirme olmadÄ±, dizi sÄ±ralanmÄ±ÅŸ durumda!');
          addLogMessage('HiÃ§ deÄŸiÅŸiklik olmadÄ± - dizi sÄ±ralanmÄ±ÅŸ durumda!');
          break;
        }
      }
      
      // TÃ¼m elemanlarÄ± sÄ±ralanmÄ±ÅŸ olarak iÅŸaretle
      for (let i = 0; i < n; i++) {
        await animateColor(i, 3, speed / 4);
      }
      
      setExplanationText('Bubble Sort tamamlandÄ±! KarmaÅŸÄ±klÄ±k: En iyi: O(n), Ortalama ve En kÃ¶tÃ¼: O(nÂ²), Bellek: O(1)');
      addLogMessage('Bubble Sort tamamlandÄ±! Bu algoritma kararlÄ± (stable) bir sÄ±ralama algoritmasÄ±dÄ±r.');
    } catch (error) {
      console.error("Bubble Sort sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Dairesel BaÄŸlÄ± Liste GÃ¶rselleÅŸtirmesi
  const visualizeCircularLinkedList = async () => {
    if (sorting) return;

    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(10); // Genel adÄ±m sayÄ±sÄ±
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle

    try {
      // SeÃ§ilen operasyona gÃ¶re uygun fonksiyonu Ã§aÄŸÄ±r
      switch (selectedOperation) {
        case 'demo':
          await performCircularLinkedListDemo();
          break;
        case 'prepend':
          await performCircularPrepend();
          break;
        case 'append':
          await performCircularAppend();
          break;
        case 'insert':
          await performCircularInsertAt();
          break;
        case 'search':
          await performCircularSearch();
          break;
        case 'deleteHead':
          await performCircularDeleteHead();
          break;
        case 'deleteTail':
          await performCircularDeleteTail();
          break;
        case 'deleteValue':
          await performCircularDeleteValue();
          break;
        case 'traverse':
          await performCircularTraverse();
          break;
        case 'clear':
          await performCircularClear();
          break;
        default:
          await performCircularLinkedListDemo();
      }
    } catch (error) {
      console.error("Dairesel BaÄŸlÄ± Liste gÃ¶rselleÅŸtirme sÄ±rasÄ±nda hata:", error);
      setExplanationText("GÃ¶rselleÅŸtirme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel BaÄŸlÄ± Liste Demo
  const performCircularLinkedListDemo = async () => {
    if (array.length === 0) {
      // Ã–rnek bir dairesel liste oluÅŸtur
      const demoList = [15, 22, 8, 41, 30];
      setArray(demoList);
      
      // Animasyon deÄŸerlerini sÄ±fÄ±rla
      const newBarColors: Animated.Value[] = [];
      for (let i = 0; i < demoList.length; i++) {
        newBarColors.push(new Animated.Value(0));
      }
      barColors.current = newBarColors;
    }

    const linkedList = [...array];
    setExplanationText('ğŸ”—â­• Dairesel BaÄŸlÄ± Liste Demo: Son dÃ¼ÄŸÃ¼mÃ¼n ilk dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterdiÄŸi dÃ¶ngÃ¼sel yapÄ±yÄ± keÅŸfedelim...');
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    // Dairesel baÄŸlÄ± liste spesifik demo adÄ±mlarÄ±
    const circularOperations = [
      { name: 'YapÄ± AÃ§Ä±klamasÄ±', action: () => explainCircularStructure(linkedList) },
      { name: 'DÃ¶ngÃ¼sel BaÄŸlantÄ±', action: () => showCircularConnection(linkedList) },
      { name: 'HEAD Pointer', action: () => showCircularHeadPointer(linkedList) },
      { name: 'BaÅŸa Ekleme O(1)', action: () => circularDemoInsert(linkedList, 'head') },
      { name: 'Sona Ekleme O(n)', action: () => circularDemoInsert(linkedList, 'tail') },
      { name: 'DÃ¶ngÃ¼sel Arama', action: () => circularDemoSearch(linkedList) },
      { name: 'DÃ¶ngÃ¼sel DolaÅŸma', action: () => circularDemoTraverse(linkedList) },
      { name: 'BaÅŸtan Silme O(1)', action: () => circularDemoDelete(linkedList, 'head') },
      { name: 'Sondan Silme O(n)', action: () => circularDemoDelete(linkedList, 'tail') },
      { name: 'DÃ¶ngÃ¼ Tespiti', action: () => showCircularLoop(linkedList) },
      { name: 'Demo TamamlandÄ±', action: () => circularDemoComplete(linkedList) }
    ];
    
    try {
      setTotalSteps(circularOperations.length);
      for (let i = 0; i < circularOperations.length; i++) {
        setCurrentStep(i + 1);
        await circularOperations[i].action();
        await wait(speed);
      }
    } catch (error) {
      console.error("Dairesel BaÄŸlÄ± Liste Demo sÄ±rasÄ±nda hata:", error);
      setExplanationText("Demo sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };

  // Dairesel baÅŸa ekleme
  const performCircularPrepend = async () => {
    if (sorting) return;
    
    // Yeni deÄŸer oluÅŸtur veya kullanÄ±cÄ± girdisini al
    const value = inputValue ? parseInt(inputValue) : Math.floor(Math.random() * 100) + 1;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(5);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa yeni bir liste oluÅŸtur
      if (array.length === 0) {
        setArray([value]);
        
        // Animasyon deÄŸerlerini sÄ±fÄ±rla
        const newBarColors: Animated.Value[] = [];
        newBarColors.push(new Animated.Value(0));
        barColors.current = newBarColors;
        
        setExplanationText(`âœ… ${value} eklendi! Liste artÄ±k 1 elemandan oluÅŸuyor.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText(`â• Dairesel baÅŸa ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`BaÅŸa ekleme: ${value} deÄŸeri`);
      await wait(speed);
      
      setCurrentStep(2);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      
      // Yeni eleman ekle
      const newArray = [value, ...array];
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(newArray.length);
      
      setCurrentStep(3);
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Yeni dÃ¼ÄŸÃ¼m vurgulandÄ±
      }
      
      setCurrentStep(4);
      setExplanationText(`â­• Son dÃ¼ÄŸÃ¼mÃ¼n next'i yeni dÃ¼ÄŸÃ¼mÃ¼ gÃ¶sterecek (dairesel baÄŸlantÄ±)...`);
      addLogMessage(`Son dÃ¼ÄŸÃ¼m(${array[array.length-1]}) -> Ä°lk dÃ¼ÄŸÃ¼m(${value}) baÄŸlantÄ±sÄ± kuruldu`);
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (barColors.current[newArray.length - 1]) {
        barColors.current[newArray.length - 1].setValue(1);
      }
      await wait(speed);
      
      // Ä°lk dÃ¼ÄŸÃ¼mÃ¼ vurgula (dairesel baÄŸlantÄ±)
      if (barColors.current[0]) {
        barColors.current[0].setValue(1);
      }
      await wait(speed);
      
      // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(newArray.length - 1, 0);
      await wait(speed);
      
      setCurrentStep(5);
      setArray(newArray);
      setExplanationText(`âœ… ${value} baÅŸa eklendi! Dairesel baÄŸlantÄ± korundu. Zaman: O(1)`);
      
    } catch (error) {
      console.error("Circular Prepend sÄ±rasÄ±nda hata:", error);
      setExplanationText("BaÅŸa ekleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel sona ekleme
  const performCircularAppend = async () => {
    if (sorting) return;
    
    // Yeni deÄŸer oluÅŸtur veya kullanÄ±cÄ± girdisini al
    const value = insertValue ? parseInt(insertValue) : Math.floor(Math.random() * 100) + 1;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(5);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa yeni bir liste oluÅŸtur
      if (array.length === 0) {
        setArray([value]);
        resetAnimationValues(1);
        setExplanationText(`âœ… ${value} eklendi! Liste artÄ±k 1 elemandan oluÅŸuyor.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText(`â• Dairesel sona ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Sona ekleme: ${value} deÄŸeri`);
      await wait(speed);
      
      setCurrentStep(2);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ bul
      for (let i = 0; i < array.length; i++) {
        barColors.current[i].setValue(1);
        await wait(speed / 3);
      }
      
      setCurrentStep(3);
      // Yeni eleman ekle
      const newArray = [...array, value];
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(newArray.length);
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (barColors.current[newArray.length - 1]) {
        barColors.current[newArray.length - 1].setValue(2); // Yeni dÃ¼ÄŸÃ¼m vurgulandÄ±
      }
      await wait(speed);
      
      setCurrentStep(4);
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i HEAD'i gÃ¶sterecek (dairesel baÄŸlantÄ±)...`);
      addLogMessage(`Yeni son dÃ¼ÄŸÃ¼m(${value}) -> Ä°lk dÃ¼ÄŸÃ¼m(${newArray[0]}) baÄŸlantÄ±sÄ± kuruldu`);
      
      // Ä°lk dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (barColors.current[0]) {
        barColors.current[0].setValue(1);
      }
      await wait(speed);
      
      // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(newArray.length - 1, 0);
      await wait(speed);
      
      setCurrentStep(5);
      setArray(newArray);
      setExplanationText(`âœ… ${value} sona eklendi! Dairesel baÄŸlantÄ± korundu. Zaman: O(n)`);
      
    } catch (error) {
      console.error("Circular Append sÄ±rasÄ±nda hata:", error);
      setExplanationText("Sona ekleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // YardÄ±mcÄ± fonksiyonlar - dairesel baÄŸlÄ± liste
  // Dairesel yapÄ± aÃ§Ä±klamasÄ±
  const explainCircularStructure = async (linkedList: number[]) => {
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    setExplanationText('ğŸ“‹â­• Dairesel BaÄŸlÄ± Liste YapÄ±sÄ±: Standart baÄŸlÄ± listeden farkÄ±, son dÃ¼ÄŸÃ¼mÃ¼n NULL yerine ilk dÃ¼ÄŸÃ¼me (HEAD) iÅŸaret etmesidir.');
    addLogMessage('Dairesel baÄŸlÄ± liste yapÄ±sÄ± aÃ§Ä±klanÄ±yor');
    await wait(speed);
    
    if (linkedList.length > 0) {
      // TÃ¼m dÃ¼ÄŸÃ¼mleri vurgula
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(1);
      });
      setExplanationText(`ğŸ”„ DÃ¼ÄŸÃ¼mler: [${linkedList.join(' â†’ ')} â†’ (BaÅŸa dÃ¶n)] - Son dÃ¼ÄŸÃ¼m tekrar ilk dÃ¼ÄŸÃ¼me dÃ¶ner.`);
      addLogMessage(`Liste yapÄ±sÄ±: [${linkedList.join(' â†’ ')} â†’ (dÃ¶ngÃ¼sel)]`);
      
      // DÃ¶ngÃ¼sel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(linkedList.length - 1, 0);
      
      await wait(speed);
    }
  };

  // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
  const showCircularConnection = async (linkedList: number[]) => {
    if (linkedList.length > 0) {
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (linkedList.length > 1 && barColors.current[linkedList.length - 1]) {
        barColors.current[linkedList.length - 1].setValue(1);
      }
      
      setExplanationText(`â­• Dairesel yapÄ±: Son dÃ¼ÄŸÃ¼m (${linkedList[linkedList.length - 1]}) NULL yerine HEAD'e (${linkedList[0]}) iÅŸaret eder.`);
      addLogMessage(`Dairesel baÄŸlantÄ±: ${linkedList[linkedList.length - 1]} â†’ ${linkedList[0]}`);
      
      await wait(speed / 2);
      
      // Ä°lk dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (barColors.current[0]) {
        barColors.current[0].setValue(1);
      }
      
      // DÃ¶ngÃ¼sel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(linkedList.length - 1, 0);
      
      await wait(speed);
    }
  };

  // Dairesel Head Pointer'Ä± gÃ¶ster
  const showCircularHeadPointer = async (linkedList: number[]) => {
    if (linkedList.length > 0) {
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      // Head'i vurgula
      if (barColors.current[0]) {
        barColors.current[0].setValue(1);
      }
      
      setExplanationText(`ğŸ‘† HEAD pointer ilk dÃ¼ÄŸÃ¼mÃ¼ (${linkedList[0]}) iÅŸaret ediyor.`);
      addLogMessage(`HEAD pointer ${linkedList[0]} deÄŸerini gÃ¶steriyor`);
      
      await wait(speed / 2);
      
      // Son dÃ¼ÄŸÃ¼mden head'e baÄŸlantÄ±yÄ± gÃ¶ster
      if (linkedList.length > 1) {
        barColors.current[linkedList.length - 1].setValue(1);
        setExplanationText(`ğŸ”„ Dairesel yapÄ±: Son dÃ¼ÄŸÃ¼m (${linkedList[linkedList.length - 1]}) HEAD'e (${linkedList[0]}) iÅŸaret ediyor.`);
        
        // DÃ¶ngÃ¼sel baÄŸlantÄ±yÄ± gÃ¶ster
        drawArrow(linkedList.length - 1, 0);
      }
      
      await wait(speed);
    }
  };

  // Dairesel pozisyona ekleme
  const performCircularInsertAt = async () => {
    if (sorting) return;
    
    // DeÄŸerleri al
    const value = insertValue ? parseInt(insertValue) : Math.floor(Math.random() * 100) + 1;
    const position = insertPosition ? parseInt(insertPosition) : Math.floor(Math.random() * (array.length));
    
    // Kontroller
    if (isNaN(value)) {
      Alert.alert('Hata', 'LÃ¼tfen geÃ§erli bir sayÄ± girin.');
      return;
    }
    
    if (isNaN(position) || position < 0 || position >= array.length) {
      Alert.alert('Hata', `LÃ¼tfen 0 ile ${array.length - 1} arasÄ±nda bir pozisyon girin.`);
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(5);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa baÅŸa ekle
      if (array.length === 0) {
        setArray([value]);
        resetAnimationValues(1);
        setExplanationText(`âœ… ${value} eklendi! Liste artÄ±k 1 elemandan oluÅŸuyor.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText(`ğŸ¯ Dairesel pozisyona ekleme: ${position + 1}. pozisyona ${value} ekleniyor...`);
      addLogMessage(`Pozisyona ekleme: ${position + 1}. pozisyona ${value} deÄŸeri`);
      await wait(speed);
      
      setCurrentStep(2);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach(color => color.setValue(0));
      
      setExplanationText(`ğŸ” Dairesel listede ${position + 1}. pozisyona dolaÅŸÄ±lÄ±yor...`);
      
      // Pozisyona kadar dolaÅŸ
      for (let i = 0; i <= position; i++) {
        barColors.current[i].setValue(1);
        await wait(speed / 3);
        
        if (i < position) {
          barColors.current[i].setValue(0);
        }
      }
      
      setCurrentStep(3);
      // Pozisyondaki dÃ¼ÄŸÃ¼mÃ¼ vurgula
      barColors.current[position].setValue(2);
      setExplanationText(`â­• Pozisyon bulundu! Dairesel baÄŸlantÄ±lar gÃ¼ncelleniyor...`);
      await wait(speed);
      
      // Yeni eleman ekle
      const newArray = [...array];
      newArray.splice(position, 0, value);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(newArray.length);
      
      // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ vurgula
      barColors.current[position].setValue(2);
      
      setCurrentStep(4);
      // Son dÃ¼ÄŸÃ¼mden HEAD'e baÄŸlantÄ±yÄ± gÃ¶ster (dairesel yapÄ±yÄ± koru)
      barColors.current[newArray.length - 1].setValue(1);
      barColors.current[0].setValue(1);
      
      // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(newArray.length - 1, 0);
      
      await wait(speed);
      
      setCurrentStep(5);
      setArray(newArray);
      setExplanationText(`âœ… ${value} deÄŸeri ${position + 1}. pozisyona eklendi! Dairesel yapÄ± korundu. Zaman: O(n)`);
      
    } catch (error) {
      console.error("Circular Insert sÄ±rasÄ±nda hata:", error);
      setExplanationText("Pozisyona ekleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Dairesel arama
  const performCircularSearch = async () => {
    if (sorting) return;
    
    // Aranacak deÄŸer
    const value = searchTarget ? parseInt(searchTarget) : array.length > 0 ? array[Math.floor(Math.random() * array.length)] : 0;
    
    if (isNaN(value)) {
      Alert.alert('Hata', 'LÃ¼tfen geÃ§erli bir sayÄ± girin.');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(array.length); // En kÃ¶tÃ¼ durumda tÃ¼m elemanlarÄ± taramak gerekir
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste boÅŸ! ${value} deÄŸeri bulunamadÄ±.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText(`ğŸ” Dairesel arama: ${value} deÄŸeri dÃ¶ngÃ¼sel olarak aranÄ±yor...`);
      addLogMessage(`Arama baÅŸladÄ±: ${value} deÄŸeri`);
      await wait(speed);
      
      // Dairesel arama - HEAD'den baÅŸla ve en fazla n eleman kontrol et
      let currentIndex = 0;
      let found = false;
      let visitedCount = 0;
      
      while (visitedCount < array.length) {
        setCurrentStep(visitedCount + 1);
        
        // Mevcut elemanÄ± vurgula
        barColors.current.forEach((color, index) => {
          if (color) color.setValue(index === currentIndex ? 1 : 0);
        });
        
        setExplanationText(`ğŸ” ${currentIndex + 1}. dÃ¼ÄŸÃ¼m (${array[currentIndex]}) kontrol ediliyor...`);
        await wait(speed / 2);
        
        if (array[currentIndex] === value) {
          // Eleman bulundu
          barColors.current[currentIndex].setValue(3); // Bulunan eleman yeÅŸil renkte
          setExplanationText(`âœ… ${value} deÄŸeri ${currentIndex + 1}. pozisyonda bulundu!`);
          addLogMessage(`Arama sonucu: ${value} deÄŸeri ${currentIndex + 1}. pozisyonda bulundu`);
          found = true;
          break;
        }
        
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        if (currentIndex === array.length - 1) {
          barColors.current[0].setValue(1); // Ä°lk dÃ¼ÄŸÃ¼mÃ¼ vurgula
          drawArrow(currentIndex, 0);
          await wait(speed / 3);
        }
        
        // Bir sonraki dÃ¼ÄŸÃ¼me geÃ§ (dairesel olarak)
        currentIndex = (currentIndex + 1) % array.length;
        visitedCount++;
      }
      
      if (!found) {
        setExplanationText(`âŒ ${value} deÄŸeri dairesel listede bulunamadÄ±! Tam dÃ¶ngÃ¼ tamamlandÄ± (${visitedCount} eleman).`);
        addLogMessage(`Arama sonucu: ${value} deÄŸeri bulunamadÄ±`);
      }
      
    } catch (error) {
      console.error("Circular Search sÄ±rasÄ±nda hata:", error);
      setExplanationText("Arama sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel baÅŸtan silme
  const performCircularDeleteHead = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(4);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste boÅŸ! Silinecek eleman yok.`);
        return;
      }
      
      const deletedValue = array[0];
      
      setCurrentStep(1);
      setExplanationText(`ğŸ—‘ï¸ Dairesel baÅŸtan silme: HEAD dÃ¼ÄŸÃ¼mÃ¼ (${deletedValue}) siliniyor...`);
      addLogMessage(`BaÅŸtan silme: ${deletedValue} deÄŸeri`);
      await wait(speed);
      
      setCurrentStep(2);
      // HEAD dÃ¼ÄŸÃ¼mÃ¼nÃ¼ vurgula
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(index === 0 ? 2 : 0); // Silinecek eleman kÄ±rmÄ±zÄ±
      });
      await wait(speed);
      
      setCurrentStep(3);
      // EÄŸer birden fazla eleman varsa son dÃ¼ÄŸÃ¼mÃ¼n baÄŸlantÄ±sÄ±nÄ± gÃ¼ncelle
      if (array.length > 1) {
        // Yeni HEAD'i vurgula
        barColors.current[1].setValue(1);
        
        // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
        barColors.current[array.length - 1].setValue(1);
        
        setExplanationText(`â­• Son dÃ¼ÄŸÃ¼mÃ¼n next'i yeni HEAD'i gÃ¶sterecek (dairesel baÄŸlantÄ±)...`);
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        drawArrow(array.length - 1, 1);
        await wait(speed);
      }
      
      setCurrentStep(4);
      // ElemanÄ± sil
      const newArray = [...array];
      newArray.shift();
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(newArray.length);
      
      // Yeni baÄŸlantÄ±larÄ± gÃ¶ster
      if (newArray.length > 0) {
        // Yeni HEAD'i vurgula
        barColors.current[0].setValue(1);
        
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        if (newArray.length > 1) {
          barColors.current[newArray.length - 1].setValue(1);
          drawArrow(newArray.length - 1, 0);
        }
      }
      
      setArray(newArray);
      setExplanationText(`âœ… ${deletedValue} silindi! HEAD gÃ¼ncellendi, dairesel baÄŸlantÄ± korundu. Zaman: O(1)`);
      
    } catch (error) {
      console.error("Circular Delete head sÄ±rasÄ±nda hata:", error);
      setExplanationText("BaÅŸtan silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel sondan silme
  const performCircularDeleteTail = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(5);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste boÅŸ! Silinecek eleman yok.`);
        return;
      }
      
      const deletedValue = array[array.length - 1];
      
      setCurrentStep(1);
      setExplanationText(`ğŸ—‘ï¸ Dairesel sondan silme: Son dÃ¼ÄŸÃ¼m (${deletedValue}) siliniyor...`);
      addLogMessage(`Sondan silme: ${deletedValue} deÄŸeri`);
      await wait(speed);
      
      setCurrentStep(2);
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ bulmak iÃ§in dolaÅŸ
      setExplanationText(`ğŸ” Son dÃ¼ÄŸÃ¼me ulaÅŸmak iÃ§in dolaÅŸÄ±lÄ±yor...`);
      for (let i = 0; i < array.length; i++) {
        barColors.current[i].setValue(1);
        await wait(speed / 4);
        
        if (i < array.length - 2) {
          barColors.current[i].setValue(0);
        }
      }
      
      setCurrentStep(3);
      // Sondan Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (array.length > 1) {
        barColors.current[array.length - 2].setValue(1);
      }
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula (silinecek)
      barColors.current[array.length - 1].setValue(2);
      await wait(speed);
      
      setCurrentStep(4);
      // EÄŸer birden fazla eleman varsa, sondan bir Ã¶nceki dÃ¼ÄŸÃ¼mÃ¼n baÄŸlantÄ±sÄ±nÄ± gÃ¼ncelle
      if (array.length > 1) {
        setExplanationText(`â­• Yeni son dÃ¼ÄŸÃ¼m (${array[array.length - 2]}) HEAD'e baÄŸlanacak...`);
        
        // HEAD'i vurgula
        barColors.current[0].setValue(1);
        
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        drawArrow(array.length - 2, 0);
        await wait(speed);
      }
      
      setCurrentStep(5);
      // ElemanÄ± sil
      const newArray = [...array];
      newArray.pop();
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(newArray.length);
      
      // Yeni baÄŸlantÄ±larÄ± gÃ¶ster
      if (newArray.length > 0) {
        // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
        barColors.current[newArray.length - 1].setValue(1);
        
        // HEAD'i vurgula
        barColors.current[0].setValue(1);
        
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        drawArrow(newArray.length - 1, 0);
      }
      
      setArray(newArray);
      setExplanationText(`âœ… ${deletedValue} silindi! Dairesel baÄŸlantÄ± korundu. Zaman: O(n)`);
      
    } catch (error) {
      console.error("Circular Delete tail sÄ±rasÄ±nda hata:", error);
      setExplanationText("Sondan silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel deÄŸer silme
  const performCircularDeleteValue = async () => {
    if (sorting) return;
    
    // Silinecek deÄŸer
    const value = deleteValue ? parseInt(deleteValue) : array.length > 0 ? array[Math.floor(Math.random() * array.length)] : 0;
    
    if (isNaN(value)) {
      Alert.alert('Hata', 'LÃ¼tfen geÃ§erli bir sayÄ± girin.');
      return;
    }
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(array.length); // En kÃ¶tÃ¼ durumda tÃ¼m elemanlarÄ± taramak gerekir
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste boÅŸ! Silinecek eleman yok.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText(`ğŸ—‘ï¸ Dairesel deÄŸer silme: ${value} deÄŸeri aranÄ±p siliniyor...`);
      addLogMessage(`DeÄŸer silme: ${value} deÄŸeri aranÄ±yor`);
      await wait(speed);
      
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      // DeÄŸeri bul
      let foundIndex = -1;
      for (let i = 0; i < array.length; i++) {
        setCurrentStep(i + 1);
        
        // Mevcut elemanÄ± vurgula
        barColors.current[i].setValue(1);
        setExplanationText(`ğŸ” ${i + 1}. dÃ¼ÄŸÃ¼m (${array[i]}) kontrol ediliyor...`);
        await wait(speed / 2);
        
        if (array[i] === value) {
          // DeÄŸer bulundu
          foundIndex = i;
          barColors.current[i].setValue(2); // Silinecek eleman kÄ±rmÄ±zÄ±
          setExplanationText(`â­• ${value} bulundu! Dairesel baÄŸlantÄ±lar gÃ¼ncelleniyor...`);
          break;
        }
        
        // BulunamadÄ±, devam et
        barColors.current[i].setValue(0);
      }
      
      if (foundIndex !== -1) {
        // DeÄŸer bulundu, sil
        
        // HEAD siliniyor mu?
        if (foundIndex === 0) {
          // HEAD siliniyor, performCircularDeleteHead ile aynÄ± iÅŸlem
          if (array.length > 1) {
            // Yeni HEAD'i vurgula
            barColors.current[1].setValue(1);
            // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula
            barColors.current[array.length - 1].setValue(1);
            
            setExplanationText(`â­• Son dÃ¼ÄŸÃ¼mÃ¼n next'i yeni HEAD'i gÃ¶sterecek...`);
            // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
            drawArrow(array.length - 1, 1);
            await wait(speed);
          }
        } 
        // Son dÃ¼ÄŸÃ¼m siliniyor mu?
        else if (foundIndex === array.length - 1) {
          // Son dÃ¼ÄŸÃ¼m siliniyor, performCircularDeleteTail ile aynÄ± iÅŸlem
          // Ã–nceki dÃ¼ÄŸÃ¼mÃ¼ vurgula
          barColors.current[foundIndex - 1].setValue(1);
          // HEAD'i vurgula
          barColors.current[0].setValue(1);
          
          setExplanationText(`â­• Yeni son dÃ¼ÄŸÃ¼m HEAD'e baÄŸlanacak...`);
          // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
          drawArrow(foundIndex - 1, 0);
          await wait(speed);
        }
        // Ortadaki bir dÃ¼ÄŸÃ¼m siliniyor
        else {
          // Ã–nceki ve sonraki dÃ¼ÄŸÃ¼mleri vurgula
          barColors.current[foundIndex - 1].setValue(1);
          barColors.current[foundIndex + 1].setValue(1);
          
          setExplanationText(`ğŸ”— Ã–nceki dÃ¼ÄŸÃ¼m sonrakine baÄŸlanacak...`);
          await wait(speed);
        }
        
        // ElemanÄ± sil
        const newArray = [...array];
        newArray.splice(foundIndex, 1);
        
        // Animasyon deÄŸerlerini gÃ¼ncelle
        resetAnimationValues(newArray.length);
        
        // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
        if (newArray.length > 0) {
          barColors.current[newArray.length - 1].setValue(1);
          barColors.current[0].setValue(1);
          drawArrow(newArray.length - 1, 0);
        }
        
        setArray(newArray);
        setExplanationText(`âœ… ${value} silindi! Dairesel yapÄ± korundu. Zaman: O(n)`);
        addLogMessage(`DeÄŸer silme: ${value} baÅŸarÄ±yla silindi`);
      } else {
        // DeÄŸer bulunamadÄ±
        setExplanationText(`âŒ ${value} deÄŸeri dairesel listede bulunamadÄ±!`);
        addLogMessage(`DeÄŸer silme: ${value} listede bulunamadÄ±`);
      }
      
    } catch (error) {
      console.error("Circular Delete value sÄ±rasÄ±nda hata:", error);
      setExplanationText("DeÄŸer silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel traverse
  const performCircularTraverse = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(array.length * 2); // Ä°ki tam tur iÃ§in
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste boÅŸ! DolaÅŸÄ±lacak eleman yok.`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText('ğŸš¶â€â™‚ï¸â­• Dairesel DolaÅŸma: Ä°ki tam dÃ¶ngÃ¼ gÃ¶sterilerek dairesel yapÄ± kanÄ±tlanacak...');
      addLogMessage(`Dairesel dolaÅŸma baÅŸladÄ±: Ä°ki tur atÄ±lacak`);
      await wait(speed);
      
      // BarlarÄ± normal renge dÃ¶ndÃ¼r
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(0);
      });
      
      // Ä°ki tam tur at
      for (let tour = 0; tour < 2; tour++) {
        setExplanationText(`ğŸ”„ ${tour + 1}. Tur baÅŸlÄ±yor...`);
        addLogMessage(`${tour + 1}. tur baÅŸladÄ±`);
        
        for (let i = 0; i < array.length; i++) {
          setCurrentStep(tour * array.length + i + 1);
          
          // Mevcut dÃ¼ÄŸÃ¼mÃ¼ vurgula
          barColors.current.forEach((color, index) => {
            if (color) color.setValue(index === i ? 1 : 0);
          });
          
          setExplanationText(`ğŸ‘£ ${tour + 1}. Tur: ${i + 1}. dÃ¼ÄŸÃ¼m (${array[i]}) ziyaret ediliyor...`);
          await wait(speed / 2);
          
          // Son dÃ¼ÄŸÃ¼me geldiÄŸimizde dairesel baÄŸlantÄ±yÄ± gÃ¶ster
          if (i === array.length - 1) {
            // HEAD'i vurgula
            barColors.current[0].setValue(1);
            
            setExplanationText(`â­• ${tour + 1}. Tur: Son dÃ¼ÄŸÃ¼mden HEAD'e dÃ¶nÃ¼ÅŸ (dairesel baÄŸlantÄ±)...`);
            // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
            drawArrow(i, 0);
            await wait(speed / 2);
          }
        }
        
        addLogMessage(`${tour + 1}. tur tamamlandÄ±`);
      }
      
      setCurrentStep(array.length * 2);
      setExplanationText(`âœ… Dairesel dolaÅŸma tamamlandÄ±! Ä°ki tam dÃ¶ngÃ¼ gÃ¶sterildi. Sonsuz dÃ¶ngÃ¼ riski var! âš ï¸`);
      
    } catch (error) {
      console.error("Circular Traverse sÄ±rasÄ±nda hata:", error);
      setExplanationText("DolaÅŸma sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };

  // Dairesel listeyi temizle
  const performCircularClear = async () => {
    if (sorting) return;
    
    setSorting(true);
    setCurrentStep(0);
    setTotalSteps(2);
    setLogMessages([]); // Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ temizle
    
    try {
      // EÄŸer liste boÅŸsa
      if (array.length === 0) {
        setExplanationText(`âŒ Liste zaten boÅŸ!`);
        return;
      }
      
      setCurrentStep(1);
      setExplanationText('ğŸ—‘ï¸ Dairesel liste tamamen temizleniyor...');
      addLogMessage(`Liste temizleme baÅŸladÄ±: ${array.length} eleman silinecek`);
      await wait(speed);
      
      // TÃ¼m elemanlarÄ± vurgula
      barColors.current.forEach((color, index) => {
        if (color) color.setValue(2); // Silinecek elemanlar kÄ±rmÄ±zÄ±
      });
      
      // Dairesel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(array.length - 1, 0);
      
      await wait(speed);
      
      setCurrentStep(2);
      // Listeyi temizle
      setArray([]);
      resetAnimationValues(0);
      
      setExplanationText('âœ… Dairesel liste tamamen temizlendi! HEAD pointer NULL olarak ayarlandÄ±.');
      addLogMessage(`Liste tamamen temizlendi`);
      
    } catch (error) {
      console.error("Circular Clear sÄ±rasÄ±nda hata:", error);
      setExplanationText("Liste temizleme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    } finally {
      setSorting(false);
    }
  };
  
  // Dairesel baÄŸlÄ± listede ekleme demo
  const circularDemoInsert = async (linkedList: number[], position: 'head' | 'tail') => {
    const value = Math.floor(Math.random() * 100) + 1;
    // BarlarÄ± normal renge dÃ¶ndÃ¼r
    barColors.current.forEach((color, index) => {
      if (color) color.setValue(0);
    });
    
    if (position === 'head') {
      setExplanationText(`â• Dairesel Listeye BaÅŸa Ekleme: Yeni dÃ¼ÄŸÃ¼m (${value}) oluÅŸturuluyor...`);
      addLogMessage(`BaÅŸa ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ”— Yeni dÃ¼ÄŸÃ¼mÃ¼n next'i mevcut HEAD'i gÃ¶sterecek...`);
      if (linkedList.length > 0 && barColors.current[0]) {
        barColors.current[0].setValue(1); // Head'i vurgula
      }
      await wait(speed / 2);
      
      linkedList.unshift(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(linkedList.length);
      
      if (barColors.current[0]) {
        barColors.current[0].setValue(2); // Yeni head'i vurgula
      }
      
      await wait(speed / 2);
      
      // Son dÃ¼ÄŸÃ¼mÃ¼ vurgula ve dairesel baÄŸlantÄ±yÄ± gÃ¶ster
      barColors.current[linkedList.length - 1].setValue(1);
      setExplanationText(`â­• Son dÃ¼ÄŸÃ¼mÃ¼n next'i yeni HEAD'i gÃ¶sterecek (dairesel baÄŸlantÄ±)...`);
      
      // DÃ¶ngÃ¼sel baÄŸlantÄ±yÄ± gÃ¶ster
      drawArrow(linkedList.length - 1, 0);
      
      setExplanationText(`âœ… ${value} baÅŸa eklendi! Dairesel yapÄ± korundu. Zaman: O(1)`);
      addLogMessage(`BaÅŸa ekleme tamamlandÄ±: ${value} eklendi, dairesel baÄŸlantÄ± gÃ¼ncellendi`);
    } else {
      setExplanationText(`â• Dairesel Listeye Sona Ekleme: ${value} iÃ§in yeni dÃ¼ÄŸÃ¼m oluÅŸturuluyor...`);
      addLogMessage(`Sona ekleme demo: ${value} ekleniyor`);
      await wait(speed / 2);
      
      setExplanationText(`ğŸ” Son dÃ¼ÄŸÃ¼mÃ¼ bulmak iÃ§in listede dolaÅŸÄ±yoruz... O(n)`);
      // Son dÃ¼ÄŸÃ¼me kadar git
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1);
        }
        await wait(speed / 4);
      }
      await wait(speed / 2);
      
      linkedList.push(value);
      setArray([...linkedList]);
      
      // Animasyon deÄŸerlerini gÃ¼ncelle
      resetAnimationValues(linkedList.length);
      
      // Yeni eklenen dÃ¼ÄŸÃ¼mÃ¼ vurgula
      if (barColors.current[linkedList.length - 1]) {
        barColors.current[linkedList.length - 1].setValue(2);
      }
  return (
    <View style={styles.container}>
      <Text style={styles.visualizationTitle}>{title} GÃ¶rselleÅŸtirmesi</Text>
      
      {/* Algoritma bilgi kartÄ± */}
      <AlgorithmInfoCard algorithmType={algorithmType} />
      
      {/* Arama algoritmalarÄ± iÃ§in input alanÄ± */}
      {(algorithmType.toLowerCase().includes('search') || algorithmType.toLowerCase().includes('arama')) && (
        <View style={styles.searchInputContainer}>
          <Text style={styles.searchInputLabel}>Aranacak SayÄ±:</Text>
          <TextInput
            style={styles.searchInput}
            value={searchTarget}
            onChangeText={setSearchTarget}
            placeholder="Ã–rn: 42"
            keyboardType="numeric"
            editable={!sorting}
          />
        </View>
      )}
      
      {/* BaÄŸlÄ± liste algoritmalarÄ± iÃ§in iÅŸlem seÃ§imi */}
      {(algorithmType.toLowerCase().includes('linked') || 
        algorithmType.toLowerCase().includes('baÄŸlÄ± liste') || 
        algorithmType.toLowerCase().includes('dairesel')) && (
        <View style={styles.linkedListControls}>
          <Text style={styles.controlLabel}>Ä°ÅŸlem SeÃ§in:</Text>
          <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.operationSelector}>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'demo' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('demo')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'demo' && styles.selectedOperationText]}>Demo</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'prepend' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('prepend')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'prepend' && styles.selectedOperationText]}>BaÅŸa Ekle</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'append' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('append')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'append' && styles.selectedOperationText]}>Sona Ekle</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'insert' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('insert')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'insert' && styles.selectedOperationText]}>Konuma Ekle</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'search' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('search')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'search' && styles.selectedOperationText]}>Ara</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'deleteHead' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('deleteHead')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'deleteHead' && styles.selectedOperationText]}>BaÅŸtan Sil</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'deleteTail' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('deleteTail')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'deleteTail' && styles.selectedOperationText]}>Sondan Sil</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'deleteValue' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('deleteValue')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'deleteValue' && styles.selectedOperationText]}>DeÄŸer Sil</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'traverse' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('traverse')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'traverse' && styles.selectedOperationText]}>DolaÅŸ</Text>
            </TouchableOpacity>
            
            {/* Ã‡ift YÃ¶nlÃ¼ BaÄŸlÄ± Liste iÃ§in geri dolaÅŸma */}
            {(algorithmType.toLowerCase().includes('doubly') || 
              algorithmType.toLowerCase().includes('Ã§ift')) && (
              <TouchableOpacity
                style={[styles.operationButton, selectedOperation === 'traverseBackward' && styles.selectedOperation]}
                onPress={() => setSelectedOperation('traverseBackward')}
                disabled={sorting}
              >
                <Text style={[styles.operationButtonText, selectedOperation === 'traverseBackward' && styles.selectedOperationText]}>Geri DolaÅŸ</Text>
              </TouchableOpacity>
            )}
            
            <TouchableOpacity
              style={[styles.operationButton, selectedOperation === 'clear' && styles.selectedOperation]}
              onPress={() => setSelectedOperation('clear')}
              disabled={sorting}
            >
              <Text style={[styles.operationButtonText, selectedOperation === 'clear' && styles.selectedOperationText]}>Temizle</Text>
            </TouchableOpacity>
          </ScrollView>
          
          {/* Ä°ÅŸlem parametreleri */}
          <View style={styles.operationParams}>
            {(selectedOperation === 'prepend' || 
              selectedOperation === 'append' || 
              selectedOperation === 'insert' || 
              selectedOperation === 'search' || 
              selectedOperation === 'deleteValue') && (
              <View style={styles.inputRow}>
                <Text style={styles.inputLabel}>DeÄŸer:</Text>
                <TextInput
                  style={styles.valueInput}
                  value={inputValue}
                  onChangeText={setInputValue}
                  placeholder="Ã–rn: 42"
                  keyboardType="numeric"
                  editable={!sorting}
                />
              </View>
            )}
            
            {selectedOperation === 'insert' && (
              <View style={styles.inputRow}>
                <Text style={styles.inputLabel}>Pozisyon:</Text>
                <TextInput
                  style={styles.valueInput}
                  value={insertPosition}
                  onChangeText={setInsertPosition}
                  placeholder="Ã–rn: 2"
                  keyboardType="numeric"
                  editable={!sorting}
                />
              </View>
            )}
          </View>
        </View>
      )}
      
      <View style={styles.controls}>
        <TouchableOpacity
          style={[styles.button, sorting && styles.disabledButton]}
          onPress={startVisualization}
          disabled={sorting}
        >
          <Text style={styles.buttonText}>BaÅŸlat</Text>
        </TouchableOpacity>
        
        <TouchableOpacity
          style={[styles.button, sorting && styles.disabledButton]}
          onPress={resetArray}
          disabled={sorting}
        >
          <Text style={styles.buttonText}>Yeni Liste</Text>
        </TouchableOpacity>
      </View>
      
      <View style={styles.speedControl}>
        <Text style={styles.speedText}>HÄ±z: </Text>
        <TouchableOpacity
          style={[styles.speedButton, speed === 1000 && styles.activeSpeedButton]}
          onPress={() => setSpeed(1000)}
          disabled={sorting}
        >
          <Text style={[styles.speedButtonText, speed === 1000 && styles.activeSpeedButtonText]}>YavaÅŸ</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.speedButton, speed === 500 && styles.activeSpeedButton]}
          onPress={() => setSpeed(500)}
          disabled={sorting}
        >
          <Text style={[styles.speedButtonText, speed === 500 && styles.activeSpeedButtonText]}>Orta</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.speedButton, speed === 250 && styles.activeSpeedButton]}
          onPress={() => setSpeed(250)}
          disabled={sorting}
        >
          <Text style={[styles.speedButtonText, speed === 250 && styles.activeSpeedButtonText]}>HÄ±zlÄ±</Text>
        </TouchableOpacity>
      </View>
      
      {/* BaÄŸlÄ± liste gÃ¶rselleÅŸtirmesi iÃ§in Ã¶zel tasarÄ±m */}
      {(algorithmType.toLowerCase().includes('linked') || 
        algorithmType.toLowerCase().includes('baÄŸlÄ± liste') || 
        algorithmType.toLowerCase().includes('dairesel')) ? (
        <View style={styles.linkedListMainContainer}>
          <Text style={styles.linkedListTitle}>BaÄŸlÄ± Liste GÃ¶rselleÅŸtirmesi</Text>
          
          {/* DÃ¼ÄŸÃ¼m gÃ¶sterimi */}
          <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.linkedListContainer}>
            <View style={styles.linkedListView}>
              {/* BoÅŸ liste mesajÄ± */}
              {array.length === 0 ? (
                <View style={styles.emptyListContainer}>
                  <Text style={styles.emptyListText}>BoÅŸ Liste</Text>
                  <Text style={styles.emptyListText}>HEAD â†’ NULL</Text>
                </View>
              ) : (
                <>
                  {/* HEAD pointer */}
                  <View style={styles.headPointerContainer}>
                    <Text style={styles.pointerLabel}>HEAD</Text>
                    <View style={styles.pointerArrow} />
                  </View>
                  
                  {/* BaÄŸlÄ± liste dÃ¼ÄŸÃ¼mleri */}
                  <View style={styles.nodesContainer}>
                    {array.map((value, index) => (
                      <View key={`node-${index}`} style={styles.nodeWrapper}>
                        {/* DÃ¼ÄŸÃ¼m */}
                        <Animated.View
                          style={[
                            styles.node,
                            {
                              backgroundColor: getBarColor(index),
                              transform: [{ translateX: barRefs.current && barRefs.current[index] ? barRefs.current[index] : new Animated.Value(0) }],
                            },
                          ]}
                        >
                          <Text style={styles.nodeValue}>{value}</Text>
                        </Animated.View>
                        
                        {/* Next pointer */}
                        {index < array.length - 1 && (
                          <View style={styles.nextPointer}>
                            <View style={styles.pointerLine} />
                            <View style={styles.pointerHead} />
                          </View>
                        )}
                        
                        {/* Son dÃ¼ÄŸÃ¼mÃ¼n NULL gÃ¶stergesi */}
                        {index === array.length - 1 && (
                          <View style={styles.nullPointer}>
                            <View style={styles.pointerLine} />
                            <Text style={styles.nullText}>NULL</Text>
                          </View>
                        )}
                        
                        {/* Ã‡ift yÃ¶nlÃ¼ baÄŸlÄ± liste iÃ§in previous pointer */}
                        {(algorithmType.toLowerCase().includes('doubly') || 
                          algorithmType.toLowerCase().includes('Ã§ift')) && 
                          index > 0 && (
                          <View style={styles.prevPointer}>
                            <View style={styles.prevPointerLine} />
                            <View style={styles.prevPointerHead} />
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                  
                  {/* TAIL pointer */}
                  {(algorithmType.toLowerCase().includes('doubly') || 
                    algorithmType.toLowerCase().includes('Ã§ift')) && (
                    <View style={styles.tailPointerContainer}>
                      <Text style={styles.pointerLabel}>TAIL</Text>
                      <View style={styles.pointerArrow} />
                    </View>
                  )}
                  
                  {/* Dairesel baÄŸlÄ± liste iÃ§in dairesel baÄŸlantÄ± */}
                  {(algorithmType.toLowerCase().includes('circular') || 
                    algorithmType.toLowerCase().includes('dairesel')) && (
                    <View style={styles.circularPointer}>
                      <View style={styles.circularPointerLine} />
                      <View style={styles.circularPointerHead} />
                    </View>
                  )}
                </>
              )}
            </View>
          </ScrollView>
          
          {/* AÃ§Ä±klama metni */}
          <View style={styles.linkedListExplanation}>
            <Text style={styles.explanationText}>{explanationText}</Text>
            {totalSteps > 0 && (
              <Text style={styles.stepCounter}>
                AdÄ±m: {currentStep} / {totalSteps}
              </Text>
            )}
          </View>
          
          {/* Ä°ÅŸlem GÃ¼nlÃ¼ÄŸÃ¼ */}
          {logMessages.length > 0 && (
            <View style={styles.logContainer}>
              <Text style={styles.logTitle}>Ä°ÅŸlem GÃ¼nlÃ¼ÄŸÃ¼:</Text>
              <ScrollView style={styles.logScroll}>
                {logMessages.map((msg, idx) => (
                  <Text key={`log-${idx}`} style={styles.logMessage}>
                    {idx + 1}. {msg}
                  </Text>
                ))}
              </ScrollView>
            </View>
          )}
        </View>
      ) : (
        <ScrollView horizontal style={styles.visualizationContainer}>
          <View style={styles.barContainer}>
            {array.map((value, index) => (
              <Animated.View
                key={`bar-${index}`}
                style={[
                  styles.bar,
                  {
                    height: (value / 100) * MAX_BAR_HEIGHT,
                    backgroundColor: getBarColor(index),
                    transform: [{ translateX: barRefs.current && barRefs.current[index] ? barRefs.current[index] : new Animated.Value(0) }],
                  },
                ]}
              >
                <Text style={styles.barText}>{value}</Text>
              </Animated.View>
            ))}
          </View>
        </ScrollView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 10,
    backgroundColor: 'white',
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 3,
    minHeight: 400,
  },
  visualizationTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2c3e50',
    marginBottom: 15,
    textAlign: 'center',
  },
  controls: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 15,
    gap: 10,
  },
  button: {
    backgroundColor: '#6c5ce7',
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 5,
    elevation: 2,
  },
  buttonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  disabledButton: {
    backgroundColor: '#a29bfe',
    opacity: 0.7,
  },
  visualizationContainer: {
    height: MAX_BAR_HEIGHT + 50,
    marginBottom: 15,
  },
  barContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    height: MAX_BAR_HEIGHT + 30,
    paddingBottom: 10,
  },
  bar: {
    width: BAR_WIDTH,
    marginHorizontal: BAR_MARGIN,
    borderTopLeftRadius: 3,
    borderTopRightRadius: 3,
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 5,
  },
  barText: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  explanationContainer: {
    padding: 10,
    backgroundColor: '#f8f9fa',
    borderRadius: 5,
    minHeight: 60,
    elevation: 1,
  },
  explanationText: {
    fontSize: 14,
    color: '#2c3e50',
    textAlign: 'center',
  },
  stepCounter: {
    fontSize: 12,
    color: '#7f8c8d',
    textAlign: 'center',
    marginTop: 8,
  },
  speedControl: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 15,
  },
  speedText: {
    fontSize: 14,
    color: '#2c3e50',
    marginRight: 10,
  },
  speedButton: {
    paddingVertical: 5,
    paddingHorizontal: 10,
    borderRadius: 15,
    backgroundColor: '#f1f2f6',
    marginHorizontal: 5,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  activeSpeedButton: {
    backgroundColor: '#6c5ce7',
    borderColor: '#5b4bc4',
  },
  speedButtonText: {
    fontSize: 12,
    color: '#2c3e50',
  },
  activeSpeedButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  searchInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 15,
    paddingHorizontal: 20,
  },
  searchInputLabel: {
    fontSize: 14,
    color: '#2c3e50',
    marginRight: 10,
    fontWeight: '500',
  },
  searchInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 14,
    backgroundColor: 'white',
    minWidth: 80,
    textAlign: 'center',
  },
  linkedListControls: {
    marginBottom: 15,
  },
  controlLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#2c3e50',
    marginBottom: 5,
    textAlign: 'center',
  },
  operationSelector: {
    flexDirection: 'row',
    marginBottom: 10,
  },
  operationButton: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 15,
    backgroundColor: '#f1f2f6',
    marginHorizontal: 4,
    borderWidth: 1,
    borderColor: '#ddd',
    elevation: 1,
  },
  selectedOperation: {
    backgroundColor: '#6c5ce7',
    borderColor: '#5b4bc4',
  },
  operationButtonText: {
    fontSize: 12,
    color: '#2c3e50',
  },
  selectedOperationText: {
    color: 'white',
    fontWeight: 'bold',
  },
  operationParams: {
    marginTop: 5,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 5,
  },
  inputLabel: {
    fontSize: 14,
    color: '#2c3e50',
    marginRight: 10,
  },
  valueInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 5,
    paddingHorizontal: 10,
    paddingVertical: 6,
    fontSize: 14,
    backgroundColor: 'white',
    minWidth: 80,
    textAlign: 'center',
  },
  logContainer: {
    marginTop: 15,
    backgroundColor: '#f8f9fa',
    borderRadius: 5,
    padding: 10,
    maxHeight: 150,
    elevation: 1,
  },
  logTitle: {
    fontSize: 14,
    fontWeight: '500',
    color: '#2c3e50',
    marginBottom: 5,
  },
  logScroll: {
    maxHeight: 120,
  },
  logMessage: {
    fontSize: 12,
    color: '#2c3e50',
    marginBottom: 2,
  },
  
  // BaÄŸlÄ± liste gÃ¶rselleÅŸtirme stilleri
  linkedListMainContainer: {
    flex: 1,
    width: '100%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    minHeight: 200,
  },
  linkedListTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#6c5ce7',
    marginBottom: 10,
    textAlign: 'center',
  },
  linkedListContainer: {
    minHeight: 150,
    maxHeight: 180,
    marginBottom: 15,
    backgroundColor: '#f7f7f7',
    borderRadius: 8,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  linkedListView: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 30,
    paddingHorizontal: 20,
    minWidth: '100%',
    position: 'relative',
  },
  nodesContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingLeft: 10,
    paddingRight: 20,
  },
  headPointerContainer: {
    position: 'absolute',
    top: -30,
    left: 20,
    alignItems: 'center',
  },
  nodeWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 10,
  },
  node: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: '#333',
    backgroundColor: '#6c5ce7',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  nodeValue: {
    color: 'white',
    fontSize: 20,
    fontWeight: 'bold',
  },
  nextPointer: {
    flexDirection: 'row',
    alignItems: 'center',
    width: 40,
  },
  pointerLine: {
    height: 3,
    backgroundColor: '#333',
    flex: 1,
  },
  pointerHead: {
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftWidth: 8,
    borderRightWidth: 8,
    borderBottomWidth: 12,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: '#333',
    transform: [{ rotate: '90deg' }],
  },
  prevPointer: {
    position: 'absolute',
    top: -20,
    left: 30,
    flexDirection: 'row',
    alignItems: 'center',
    width: 40,
  },
  prevPointerLine: {
    height: 3,
    backgroundColor: '#2980b9',
    flex: 1,
  },
  prevPointerHead: {
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftWidth: 8,
    borderRightWidth: 8,
    borderBottomWidth: 12,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: '#2980b9',
    transform: [{ rotate: '-90deg' }],
  },
  nullPointer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 10,
  },
  nullText: {
    color: '#e74c3c',
    fontWeight: 'bold',
    fontSize: 16,
  },
  pointerLabel: {
    color: '#2c3e50',
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 5,
  },
  pointerArrow: {
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftWidth: 8,
    borderRightWidth: 8,
    borderTopWidth: 12,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderTopColor: '#2c3e50',
  },
  tailPointerContainer: {
    position: 'absolute',
    top: -35,
    right: 20,
    alignItems: 'center',
  },
  circularPointer: {
    position: 'absolute',
    bottom: -20,
    left: 30,
    right: 30,
    height: 40,
    borderBottomWidth: 3,
    borderLeftWidth: 3,
    borderRightWidth: 3,
    borderColor: '#8e44ad',
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
  },
  circularPointerLine: {
    position: 'absolute',
    top: -3,
    left: 0,
    height: 3,
    width: '100%',
    backgroundColor: '#8e44ad',
  },
      circularPointerHead: {
    position: 'absolute',
    top: -12,
    left: 0,
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftWidth: 8,
    borderRightWidth: 8,
    borderBottomWidth: 12,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: '#8e44ad',
    transform: [{ rotate: '-90deg' }],
  },
  
  // Dairesel baÄŸlÄ± liste gÃ¶rselleÅŸtirmesi iÃ§in ek stiller
  circularPointerContainer: {
    position: 'absolute',
    bottom: -25,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  circularIndicator: {
    color: '#8e44ad',
    fontWeight: 'bold',
    fontSize: 18,
  },
  emptyListContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 30,
  },
  emptyListText: {
    fontSize: 18,
    color: '#7f8c8d',
    marginBottom: 10,
  },
  linkedListExplanation: {
    padding: 10,
    backgroundColor: '#f8f9fa',
    borderRadius: 5,
    minHeight: 60,
    marginBottom: 10,
  },
});

  // resetAnimationValues fonksiyonu - animasyon deÄŸerlerini sÄ±fÄ±rlamak iÃ§in
  const resetAnimationValues = (length: number) => {
    // Animasyon deÄŸerlerini sÄ±fÄ±rla
    const newBarColors: Animated.Value[] = [];
    
    for (let i = 0; i < length; i++) {
      newBarColors.push(new Animated.Value(0));
    }
    
    barColors.current = newBarColors;
  };

  // Dairesel baÄŸlÄ± liste demo fonksiyonlarÄ±
  // Dairesel demoda baÅŸa ya da sona ekleme
  const circularDemoInsert = async (linkedList: number[], position: 'head' | 'tail') => {
    try {
      const value = Math.floor(Math.random() * 100) + 1;
      setExplanationText(`Dairesel baÄŸlÄ± listeye ${position === 'head' ? 'baÅŸa' : 'sona'} ${value} deÄŸeri ekleniyor...`);
      addLogMessage(`${position === 'head' ? 'BaÅŸa' : 'Sona'} ekleme: ${value} deÄŸeri`);
      
      await wait(speed);
      
      if (position === 'head') {
        const newArray = [value, ...linkedList];
        setArray(newArray);
        resetAnimationValues(newArray.length);
      } else {
        const newArray = [...linkedList, value];
        setArray(newArray);
        resetAnimationValues(newArray.length);
      }
      
      setExplanationText(`âœ… ${value} ${position === 'head' ? 'baÅŸa' : 'sona'} eklendi ve dairesel baÄŸlantÄ± korundu!`);
      await wait(speed);
    } catch (error) {
      console.error(`Circular demo insert (${position}) error:`, error);
      setExplanationText("Ä°ÅŸlem sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };
  
  // Dairesel demoda arama iÅŸlemi
  const circularDemoSearch = async (linkedList: number[]) => {
    try {
      if (linkedList.length === 0) {
        setExplanationText("BoÅŸ liste! Arama yapÄ±lamaz.");
        return;
      }
      
      const target = linkedList[Math.floor(Math.random() * linkedList.length)];
      setExplanationText(`ğŸ” Dairesel listede ${target} deÄŸeri aranÄ±yor...`);
      addLogMessage(`Arama: ${target} deÄŸeri`);
      
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1); // Ä°ncelenen dÃ¼ÄŸÃ¼m
        }
        await wait(speed / 2);
        
        if (linkedList[i] === target) {
          if (barColors.current[i]) {
            barColors.current[i].setValue(3); // Bulundu
          }
          setExplanationText(`âœ… ${target} deÄŸeri ${i+1}. dÃ¼ÄŸÃ¼mde bulundu!`);
          addLogMessage(`${target} deÄŸeri ${i+1}. dÃ¼ÄŸÃ¼mde bulundu`);
          return;
        }
        
        if (barColors.current[i]) {
          barColors.current[i].setValue(0); // Normal renge dÃ¶n
        }
      }
      
      setExplanationText(`${target} deÄŸeri listede bulunamadÄ±.`);
    } catch (error) {
      console.error("Circular demo search error:", error);
      setExplanationText("Arama sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };
  
  // Dairesel demoda dolaÅŸma
  const circularDemoTraverse = async (linkedList: number[]) => {
    try {
      setExplanationText("â†©ï¸ Dairesel baÄŸlÄ± listede dolaÅŸma: Her dÃ¼ÄŸÃ¼mÃ¼ ziyaret et ve baÅŸtaki dÃ¼ÄŸÃ¼me geri dÃ¶n...");
      addLogMessage("Dairesel dolaÅŸma baÅŸlatÄ±ldÄ±");
      
      // Ä°lk tur
      for (let i = 0; i < linkedList.length; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1); // Ziyaret ediliyor
        }
        await wait(speed / 2);
        
        if (barColors.current[i]) {
          barColors.current[i].setValue(4); // Ziyaret edildi
        }
        setExplanationText(`${i+1}. dÃ¼ÄŸÃ¼m (${linkedList[i]}) ziyaret edildi.`);
      }
      
      // DaireselliÄŸi gÃ¶stermek iÃ§in ikinci tur (ilk birkaÃ§ eleman)
      const secondRoundCount = Math.min(3, linkedList.length);
      for (let i = 0; i < secondRoundCount; i++) {
        if (barColors.current[i]) {
          barColors.current[i].setValue(1); // Tekrar ziyaret ediliyor
        }
        await wait(speed / 2);
        
        setExplanationText(`â­• Dairesel yapÄ± nedeniyle ${i+1}. dÃ¼ÄŸÃ¼m (${linkedList[i]}) tekrar ziyaret edildi.`);
        
        if (barColors.current[i]) {
          barColors.current[i].setValue(0); // Normal renge dÃ¶n
        }
      }
      
      // TÃ¼m dÃ¼ÄŸÃ¼mleri normal renge Ã§evir
      barColors.current.forEach(color => {
        if (color) color.setValue(0);
      });
      
      setExplanationText("âœ… Dairesel dolaÅŸma tamamlandÄ±! Listenin sonunda baÅŸa dÃ¶nÃ¼lerek tekrar dolaÅŸÄ±labilir.");
      addLogMessage("Dairesel dolaÅŸma tamamlandÄ±");
    } catch (error) {
      console.error("Circular demo traverse error:", error);
      setExplanationText("DolaÅŸma sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };
  
  // Dairesel demoda silme iÅŸlemi
  const circularDemoDelete = async (linkedList: number[], position: 'head' | 'tail') => {
    try {
      if (linkedList.length === 0) {
        setExplanationText("BoÅŸ liste! Silme yapÄ±lamaz.");
        return;
      }
      
      if (linkedList.length === 1) {
        setExplanationText("Son eleman siliniyor, liste boÅŸ olacak.");
        addLogMessage(`Son eleman (${linkedList[0]}) silindi, liste boÅŸ`);
        await wait(speed);
        setArray([]);
        return;
      }
      
      if (position === 'head') {
        setExplanationText("Dairesel listenin baÅŸÄ±ndan eleman siliniyor...");
        addLogMessage(`BaÅŸtan silme: ${linkedList[0]} deÄŸeri`);
        
        if (barColors.current[0]) {
          barColors.current[0].setValue(2); // Silinen dÃ¼ÄŸÃ¼m
        }
        await wait(speed);
        
        const newArray = linkedList.slice(1);
        setArray(newArray);
        resetAnimationValues(newArray.length);
        
        setExplanationText(`âœ… BaÅŸtaki eleman silindi ve dairesel baÄŸlantÄ± korundu! Zaman: O(1)`);
      } else {
        setExplanationText("Dairesel listenin sonundan eleman siliniyor...");
        addLogMessage(`Sondan silme: ${linkedList[linkedList.length-1]} deÄŸeri`);
        
        if (barColors.current[linkedList.length-1]) {
          barColors.current[linkedList.length-1].setValue(2); // Silinen dÃ¼ÄŸÃ¼m
        }
        await wait(speed);
        
        const newArray = linkedList.slice(0, -1);
        setArray(newArray);
        resetAnimationValues(newArray.length);
        
        setExplanationText(`âœ… Sondaki eleman silindi ve dairesel baÄŸlantÄ± korundu! Zaman: O(n)`);
      }
    } catch (error) {
      console.error(`Circular demo delete (${position}) error:`, error);
      setExplanationText("Silme sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };
  
  // Dairesel demoda dÃ¶ngÃ¼ tespiti
  const showCircularLoop = async (linkedList: number[]) => {
    try {
      setExplanationText("ğŸ”„ Dairesel baÄŸlÄ± listelerde dÃ¶ngÃ¼ tespiti: Floyd'un YavaÅŸ-HÄ±zlÄ± Ä°ÅŸaretÃ§i algoritmasÄ±");
      addLogMessage("DÃ¶ngÃ¼ tespiti baÅŸlatÄ±ldÄ±");
      
      if (linkedList.length < 2) {
        setExplanationText("DÃ¶ngÃ¼ tespiti iÃ§in en az 2 eleman gerekli.");
        return;
      }
      
      let slow = 0;
      let fast = 0;
      
      await wait(speed);
      
      setExplanationText("YavaÅŸ iÅŸaretÃ§i 1 adÄ±m, hÄ±zlÄ± iÅŸaretÃ§i 2 adÄ±m ilerler. EÄŸer buluÅŸurlarsa, dÃ¶ngÃ¼ vardÄ±r.");
      
      // YavaÅŸ ve hÄ±zlÄ± iÅŸaretÃ§ileri baÅŸlat
      if (barColors.current[slow]) {
        barColors.current[slow].setValue(1); // YavaÅŸ iÅŸaretÃ§i
      }
      await wait(speed);
      
      let step = 1;
      while (step <= linkedList.length * 2) {
        // YavaÅŸ iÅŸaretÃ§iyi 1 adÄ±m ilerlet
        if (barColors.current[slow]) {
          barColors.current[slow].setValue(0); // Ã–nceki konumu temizle
        }
        slow = (slow + 1) % linkedList.length;
        if (barColors.current[slow]) {
          barColors.current[slow].setValue(1); // Yeni konum
        }
        
        // HÄ±zlÄ± iÅŸaretÃ§iyi 2 adÄ±m ilerlet
        if (barColors.current[fast]) {
          barColors.current[fast].setValue(0); // Ã–nceki konumu temizle
        }
        fast = (fast + 2) % linkedList.length;
        if (barColors.current[fast]) {
          barColors.current[fast].setValue(2); // Yeni konum
        }
        
        setExplanationText(`AdÄ±m ${step}: YavaÅŸ=${linkedList[slow]}, HÄ±zlÄ±=${linkedList[fast]}`);
        await wait(speed);
        
        // BuluÅŸma kontrolÃ¼
        if (slow === fast) {
          setExplanationText("âœ… DÃ¶ngÃ¼ tespit edildi! YavaÅŸ ve hÄ±zlÄ± iÅŸaretÃ§iler buluÅŸtu.");
          addLogMessage("DÃ¶ngÃ¼ tespit edildi");
          break;
        }
        
        step++;
      }
      
      // TÃ¼m dÃ¼ÄŸÃ¼mleri normal renge Ã§evir
      barColors.current.forEach(color => {
        if (color) color.setValue(0);
      });
      
      setExplanationText("Dairesel baÄŸlÄ± listeler Ã¶zellikle Ã§evrimsel iÅŸlemler iÃ§in avantajlÄ±dÄ±r.");
    } catch (error) {
      console.error("Show circular loop error:", error);
      setExplanationText("DÃ¶ngÃ¼ tespiti sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };
  
  // Dairesel demo tamamlandÄ±
  const circularDemoComplete = async (linkedList: number[]) => {
    try {
      setExplanationText("âœ… Dairesel BaÄŸlÄ± Liste demosunu tamamladÄ±nÄ±z!");
      addLogMessage("Demo tamamlandÄ±");
      
      await wait(speed);
      
      setExplanationText("Dairesel BaÄŸlÄ± Listeler, son dÃ¼ÄŸÃ¼mÃ¼n ilk dÃ¼ÄŸÃ¼me iÅŸaret ettiÄŸi Ã¶zel bir baÄŸlÄ± liste tÃ¼rÃ¼dÃ¼r. DÃ¶ngÃ¼sel yapÄ±larÄ± nedeniyle, listenin herhangi bir yerinden tÃ¼m listeye eriÅŸim saÄŸlanabilir.");
    } catch (error) {
      console.error("Circular demo complete error:", error);
      setExplanationText("Demo tamamlama sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  };

export default AlgorithmVisualization;
}